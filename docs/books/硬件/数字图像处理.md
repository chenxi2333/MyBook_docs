# 数字图像处理

> 笔记中的内容来自于图像工程（第四版）、数字图像处理、数字图像处理Matlab版

# Chapter 2 - 数字图像基础

## 像素间的基本关系

1. 相邻像素：一个像素上下左右的4个像素点为“4邻域”，用 $N_4(p)$表示；周围的8个像素叫做“8邻域”，用$N_8(p)$表示，以此类推。对角的四个像素点称为N~D~(p)。
   1. 如果一个邻域包含p，则称改邻域为闭邻域。
2. 邻接：空间相邻并且灰度值相似。
   1. 在二值图像中，1的像素p周围有一个1的像素q，那么q是p的邻接。
      1. 4邻接和8邻接，分别是q在 $N_4(p)$和 $N_8(p)$中的叫法。
      2. m-邻接：用来消除歧义性的，表示q为4邻接或者对角连接（斜的,并且拐弯的像素点上没有）。
   2. 邻接关系是相互的，但并不传递。

3. 联通：两个像素之间存在通路。通路也分为4通路<m通路<8通路。

   1. 联通分量：S联通到改像素的像素集。
   2. 联通集S：对于S中的任何像素p，S之中只存在一个联通分量。

4. 区域和边界：

   1. 区域：一个联通集就是一个区域
   2. 边界：相邻像素中存在不一样的——不同的邻接（4或者8）边界像素的集合就不同。
      1. 区分内边界和外边界：内边界是它本身，包围它的一圈则是外边界。——为了保证边界形成一个闭合回路，很多算法会使用外边界——这样就能保证形成闭合的回路。
      2. 整幅图像则边界定义为它的第一行、第一列。其它类似的情况也是，图像区域的边缘可以作为它的边界。
      3. 需要注意的是 边缘≠边界。

5. 距离度量：

   1. 欧几里得测度：

   $$
   D_e(p,q)=[(x-u)^2+(y-v)^2]^{\frac{1}{2}}
   $$

   2. 城市街区距离：
      $$
      D_4(p,q)=|x-u|+|y-v|
      $$
      
   3. 棋盘距离：
      $$
      D_8=max(|x-u|,|y-v|)
      $$

### 数字图像处理所使用的基本数学工具

1. 矩阵：图像本身就是矩阵
2. 线性运算与非线性运算：图像本身的变化
3. 算术运算：图像的颜色、灰度、亮度等变化
4. 集合运算和逻辑运算
5. 空间运算：直接对像素的操作
   1. 单像素运算：灰度、反色等
   2. 邻域运算：处理一个邻域所有的数据，比如用邻域的平均值给中心像素就可以造成模糊。
   3. 几何变换：集合改变图像像素的空间排列以及做一些灰度内插。造成图像的旋转、翻折等效果。（本质上还是矩阵的操作）
   4. 图像配准：将两幅图像对照，将一些变换过的图像还原到原始角度和状态。
6. 向量和矩阵运算
7. 图像变换：将空间域进入变换域（先行操作，如傅里叶变换，可以应用在噪声滤波等工作上）操作，再转换成空间域。
8. 图像灰度和随机变量



## Matlab

- 离散的图像可以使用矩阵表示，每个像素点对应了矩阵的一个坐标。
  - 灰度图在Matlab中储存为二维的矩阵，RGB图像保存为一个三维矩阵——它的第三个维度有3个，分别表示了RGB。
- 读取图像、显示图像以及图像信息
- 一幅图像可以用 数据格式+图像类型来描述类型：
  - double类型用于计算，大部分的8位深度的图像能够使用uint8来表示。
  - matlab工具箱支持四种类型的图像——亮度、二值、索引、RGB图像。
    - 亮度图像是图像亮度的矩阵
    - 二值图像：只有01的图像（Matlab中可以使用imshow(f_0>128)来获取一个中间分开的二值图像）
    - ？
- 数据、图像之间的转化本质上还是数据之间的转化——
  - `im2uint(f)`这个函数的本质就是把0-1之间的数值转化为0-255（超过按照0或者255计算）
  - `mat2gray(f)`则是把任意的数组归一化到0-1之间。
- 数组索引：就是Matlab通用的数组索引。
- `operation(A，dim)`的含义是沿着数组A的特定维度进行操作（右侧维度高，从低到高排序），对这一个维度进行操作。
- Matlab是为了数组运算而诞生的，因此尽量使用数组运算可以提高程序效率。
- 交互：
  - input后面的s是把输入作为字符串，允许任何的输入。
  - 输出的形式很多样，除了disp函数，也可以使用一些转化后不加；来进行直接的输出；或者可以把几个变量组合一下然后一起处理一下输出。



# Chapter 3- 灰度变换与空间滤波

- 空间域：是指图像平面本身，空间域内的图像处理是指使用直接对于像素进行处理。一般来说这些处理都是直观并且易于理解的。

  变换域：对于图像本身的矩阵做出一定的变化后在另外一个层面上进行变化的过程，相对于前者来说更加难于理解。

- 空间域的主要变化包括了灰度处理和空间滤波

  - 灰度处理：邻域处理技术（一个点的变化跟它邻域内的点相关）和点处理技术（只跟它本身相关）

- s和r分别表示了变化后的g和变化前的f在任意点上的灰度

## 一些基本的灰度变换函数

1. 图像反转：$s=L-1-r$，灰白图像的反色变化。（L是灰度的分辨率，一般是256）
2. 对数变换：$s=clog(1+r)$,c是常数，这种变化可以扩展暗像素值同时压缩高灰度。反对书变换正好相反。
3. 幂律（伽马）变换：$s=cr^{\gamma}$,伽马矫正，非常常用，通过调节γ的值可以调整图片。显示器由于本身的阴极射线管特性可能会产生一定的偏差，这种偏差通常可以使用伽马矫正。
4. 分段线性函数变换：对比拉伸（把灰度不明不暗的一部分像素向两侧拉伸）、灰度分层级（突出某一个范围灰度的数值）、比特平面分层（256的灰度值本质上是8个bit的值，这个方法是通过突出某一个bit对于整个图像的贡献，比较极端的情况下就是仅看某几位来制作一个低分级的图像，这种图虽然深度减少、但同时体积减少、也滤除掉了一些不必要的细节）

## 直方图处理

- 一幅L级别的灰度图像$f(x,y)$,它的非归一化直方图定义为

$$
h(r_k)=n_k,k=0,1,2,...,L-1
$$

​	式中$n_k$是f中灰度为$r_k$的像素数量，并且细分的灰度级成为直方图容器。归一化定义为：
$$
p(r_k)=\frac{h(r_k)}{MN}=\frac{n_k}{MN}
$$
M和N为图像的行数和列数。

1. 直方图均衡化：这两个本质上是一个“捏橡皮泥”的变化，将本来分布不均匀的概率密度变得“平整”或者变成规定的模样——本来集中分布的最左边现在就移动到了灰度的最左边（本质上就是一种拉伸，通过减少灰度的层级来提高整体的对比度）
2. 直方图匹配：原理其实也很简单——就是先把规定的那种也转化成为平整的状态，然后两个平整状态下对每一个层级进行对应，再次映射之后就可以得到原来的到规定的直方图的映射关系了。
3. 局部直方图处理
4. 使用直方图统计量增强图像

## 空间滤波基础

1. 线性滤波的基础原理：滤波核和图像像素的卷积。可以对比一维的时域信号上的卷积：

$$
g(x,y)=\sum_{s=a}^{a}\sum_{s=b}^{b}w(s,t)f(x+s,y+t)
$$

2. 可分离滤波核：将滤波核分解成一个列向量和一个行向量和乘积，再利用卷积的结合律分别做两次卷积，可以减少运算的次数
3. 卷积再频率域中很重要，时域和频域，与图像的空间域和频率域有一些非常类似的性质。
   1. 比如空间域的卷积和频率域的乘法是等效的，空间中的冲激和频率域中的常数等效。
   2. 所谓的滤波就是修改频率域的内容，使其成为我们希望的样子。而达成这一点一般就会用到空间域中的特定卷积。频率域中的滤波器通过反傅里叶变换得到的空间域对应着滤波核。
4. 如何构建空间滤波核：
   1. 直观的数学性质（比如平均算法）
   2. 形状具有所需要的性质的二维空间函数取样。
   3. 特定频率响应的空间滤波器。

## 平滑（低通）滤波器

1. 所谓的平滑，就是让空间中相邻的像素过渡更加平滑，在边缘的部分通常会造成模糊的效果，而对于一些噪音点以及瑕疵也能够
2. 盒式滤波器核：一个元素全都为常数的，前面乘以归一化系数（保证核中所有元素的和为1）的滤波器盒。
3. 低通高斯滤波器核：式子上看就是一个中间高四周低的高斯分布函数$G(r)=Ke^{-\frac{r^2}{2\sigma^2}} $,r是滤波核中心到该点的距离；
   1. 高斯核具有可分离性：一般来说滤波核大小没必要超过$6\sigma$，增加不必要的计算量。
   2. 高斯核之间互相卷积和相乘所得到的结果依旧是一个高斯核。借助这一点性质，复合核中的高斯核可以直接使用公式合并，减少卷积带来运算量。
   3. 高斯核的好处在于可以调整参数来达到不同的平滑效果。相比于盒式核，高斯核的边缘滤波效果也更加平滑一些。
4. 关于滤波过程中的填充问题：除了0填充之外，还可以使用镜像反射或者拓展边缘的像素值的方法进行填充。后两种方法将图像“特性”拓展到了边框之外，这样在滤波的处理中能够让边缘部分的处理更加得当。
5. 平滑核的滤波效果是和核的大小以及图片大小相关，核的大小也要记得随着图片尺寸的改变而做出调整。
   1. 一些常用的应用：
      1. 先使用平滑滤波滤掉一些无关的细节，然后再使用阈值处理，获取二值图像
      2. 使用低通滤波校正阴影。
6. 统计排序滤波器：非线性的滤波器，例如中值滤波器——在核的大小中取出像素的中值作为中心像素。这个值代表了图中50％的分割，是一个典型并且很常见的统计滤波器。

## 锐化（高通）空间滤波器

1. 所谓的锐化，是突出灰度的过渡——让对比更加强烈，这一点核平滑完全的相反。

2. 离散函数的一阶导数锐化滤波器：类比一维离散信号的导数使用了离散差分方程的形式。

   1. 在空间中的导数定义方法：$ \frac{\delta f}{\delta x}=f(x+1,y)-f(x,y)$偏导数。在灰度图像的边缘，一阶的导数通常会产生较宽的边缘，因此二阶导数可以增强更加精细的细节，是一个更加适合于锐化图像的一个理想特性。

3. 使用二阶导数锐化图像——拉普拉斯

   1. 拉普拉斯算子的公式如下：

   $$
   \Delta^2f = \frac{\delta^2 f}{\delta x} + \frac{\delta^2 f}{\delta y^2} \\= f(x+1,y)+f(x-1,y)-2f(x,y)+f(x,y+1)+f(x,y-1)-2f(x,y)\\=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)
   $$

   

   2. 从公式上讲，这是一个核的卷积：中间-4周围为1的卷积3*3核与图像进行卷积运算后的结果——拓展一下之后8邻接中的4个角落同样填充上1，就得到了高通滤波器。对于图像的二阶导数和可以用一个特定的卷积来进行替代。
   3. 在实际的匀速过程中，直接的拉普拉斯算子并不具备连续性，因此一般选择拉普拉斯算子乘以锐化的系数在叠加在原来的图上使用，来获得连续的图像。也可以看作是卷积核前乘以系数之后中心加了1得到的结果。

   $$
   g(x,y)=f(x,y)-c\Delta^2f
   $$

   4. 一般来说，锐化的结果能够强化图像的高对比度的边缘部分。图像可能会有负值，因此很多时候需要额外的处理才能够使用好——需要调参

4. 钝化掩蔽和高提升滤波

   1. 钝化掩蔽：模糊原图像，原图像减去模糊的图像，将差（称为模板）和原图像相加。$ g_{mask}=f(x,y)-\overline{f}(x,y),g=f+kg_{mask}$。
   2. k=1称为钝化掩蔽，k>1则称为高提升滤波，从原理上看其实跟高通滤波器的设计如出一辙，不过在中间的锐化上并没有高通滤波器效果那么显著。不过在过去数字技术不发达的时代，这种技术可以使用在印刷和出版业。
   3. k的提高可以显著提升锐化的程度，但是也会加剧画面的不自然程度。

5. 使用一阶导数锐化图像——梯度

   1. 一阶导数的实现使用的是梯度。连续域中的梯度，使用的是偏导数实现，在离散域中，生成一个梯度图形需要做出一些离散近似。

   1. 需要一种方法，能够让梯度照顾到一个像素点更多邻域内的点的算法:为了达成这一点，一般来说为了让横轴和纵轴都被照顾到，会分别计算出横轴和纵轴方向上的梯度，再使用加和平方根或者绝对值的和，用这种方法来计算出一个“四面八方的梯度”。
   
   2. Roberts提出的交叉差算法利用了一个偶数的核，称为罗伯特交叉梯度算子。但是现代的计算中通常喜欢使用奇数的核，如下（称为Sobel算子）。这种算法中，某一个位置的梯度计算，是通过两个sobel核卷积后，再使用加和平方根计算出来的。
      $$
      g_x=\frac{\delta f}{\delta x} = (z_7+2z_8+z_9)-(z_1+2z_2+z_3)
      \\g_y=\frac{\delta f}{\delta y} = (z_3 + 2z_6+z_9)-(z_1+2z_4+z_7)\\
      M(x,y)=[g_x^2+g_y^2]^{0.5}
      $$
      
   3. 梯度在边缘检测上应用更加广泛。

## 低通、高通、带阻和带通滤波器

1. 有了低通和高通滤波器之后，傣族和带通滤波器就可以通过上述二者滤波器核的线性组合来生成。

## 组合使用空间增强方法

对于一个任务，很多时候必须尝试组合使用各种方法，并进行不停的调参来进行综合。

## Matlab

### 灰度变换函数

1. imadjust和stretchlim：很好理解的，看书上的图和例程就能够知道参数是啥了，第一个函数对应的是伽马变换，以及一些反色和简单的分段线性都能够通过它来完成。

   1. 第二个是用来计算低高参数的（LOW_IN 和 HIGH_IN）

      1. 注意的是，以下的变化需要先对图像进行从255到1的映射（mat2gray），然后才能够正常的进行在0-1灰度的映射运算，最后还需要再次转化回到0-255上。这种做法的好处在于，对于不同的图像（有的是uint8有的是uint16）可以使用同一个映射算法。

   2. 对数和对比图拓展变化：

      1. 简单说就是对于每一个像素进行特定的变化即可 g=c*log(1+(f))
         然后在此之上加上一些限制就可以实现灰度对数变化——里层限制在0到1，外层拉伸到0，255。

   3. 指定任意灰度变换：就是一个多段函数的映射而已

      1. ```matlab
         g = interp1(z,T,f)%这个函数是一阶插值的函数，作用是生成一个和f一一对应的g，对应的方法则是通过z和T组成的函数图形确定的。
         z=linspace(0,1,numel(T))'%这句话含义在于自动生成一个和T相同大小的z，均衡的作为灰度的横坐标。。。
         
         % 例子
         T=[0,0.1,0.9,1]';z=linspace(0,1,numel(T))';
         g = im2uint8(mat2gray(interp1(z,T,mat2gray(f))));%这个函数是一阶插值的函数
         ```

      2. 对于f中的像素值，interp1首先查找横坐标的值，然后内插相应的T中的值，输出相应像素位置的g内插值。

2. 针对灰度变换的某些公用M-函数——动手设计一些实用的灰度处理工具

   1. 小知识：matlab中可以使用varargin，当作一个可变参数列表使用。
   2. 现在narginchk取代了书上所用的error(narghk)
   3. 用于标定灰度的M-函数用来在不同精度的图像之间互相转化。在附录中有一个gscale()函数做的这件事情

### 直方图处理和函数绘图	

1. 生成直方图imhist(f,b)
   1. numel是一个非常有用的函数，能够一键获得一个数组中的全部元素个数。
   2. 其他的图：imhiat、bar/stem/plot都是可以的。
      1. xlim('auto')可以自动标定坐标尺度
2. 直方图均衡化histeq
   1. 事实证明，这种方法在一些某几个灰度级别特别众多的图像处理上并不适用（离散的特性决定并不可能均匀拉伸）。
3. 直方图匹配histeq ,输入图像和需要匹配的直方图。
4. 函数adapthisteq自适应直方图



### 空间滤波

1. 空间滤波的函数叫做imfilter(f,w，'conv'，'replicate')——可以选择滤波模式（是否旋转180°）、边界选项（边界的拓展方式）、大小选项（拓展的边缘是否要包含进图像）
2. 非线性空间滤波：nlfilter和colfilter（后者经常使用），配合函数padarry使用，这个函数的作用是拓展图像的边缘。

### 图像处理工具箱

1. 线性空间滤波器：使用fspecial()函数可以方便快捷的生成滤波器核，甚至连前置参数都省了。
   1. 需要注意的地方就是类型转换，因为uint8的类型，因此负值有时候会被裁成0，可以先转换成float之后再卷积。
2. 梯度图形的计算中，两个方向的sobel算子通过转置得到，矩阵的开方需要做一次类型转换函数。
3. 非线性空间滤波：ordfilt2(f,order,domain)——使用哪些像素，第多少大小的像素作为中间的像素值;midfilt2(f,[m,n],padopt)——中值滤波。

### 将模糊技术用于灰度变换核空间滤波

1. 理论基础：模糊控制（略过）



# Chapter5 频率域滤波

1. 傅里叶变换：将信号从时间域变换到频率域的变换——任何周期与非周期的函数都可以表示成为不同的频率的正弦函数的和。
