# 《C和指针》
### Chapter 6 指针
1. **`&`是取址（获取变量的地址）；`*`是提领（获取指针位置的值**
2. 不能简单地通过检查一个值的位数来判断它的类型。
   1. 一个变量是在某个地址上一系列01构成的，怎么“解释”它们，它们就是什么值。
3. 通过指针的访问：是为“间接访问”
4. 非法指针：指针没有固定的指向位置，或者指向了一个“无法预测”的位置
   1. NULL指针：对指针赋零值，指向了零地址，这个地址不应该被间接访问；
   2. 所有的指针在初始化的时候要么去指向一个NULL，要么就直接赋值。

5. 指针的指针：`int **c`
6. ++cp:表明是返回增值后的结果；cp++则返回一份cp的拷贝再增值；
   1. 两者都增加了cp的值

___



### Chapter 7 函数

1. 函数的定义
2. 函数的声明：
   1. 声明是为编译器提供函数的必要信息（参数的名字是给用户看的）
   2. 编译器会对没加声明的函数默认返回一个整型
3. 函数的参数
   1. 传传递：获得的是值得copy值，所谓“传递参数”；
   2. 地址传递：实际值，数组是传递的地址，因而是“实际参数”
4. ADT和黑盒：
   1. ADT：抽象数据类型，用函数来实现“黑盒设计”
5. 递归
   1. 递归的形式简单，但是冗余成本巨大
6. 可变参数列表
   1. 用 stdarg 的宏来定义可变参数的列表，在标准库中定义了va_list。

___



### Chapter 8 数组

1. ```
   数组的声明：int b[10];
   c = &a[0]和c=a等价；
   int array[5]={1,2,3,4,5};
   int* ap = array + 2;
   结果：*ap=3,ap[0]=3,*ap+2=5,*(ap+2)=5,ap[-1]=2
   ```

   数组名是一个指针常量，指向数组的第一个元素。array[i]和*(array+i)完全等价,甚至i可以是负数。

2. 过去的编译器不会检查下标，因而经常会产生溢出的错误

3. 指针与下标：指针在某些情况下比下标更加有效率，

   1. TIPS：大多数时候，为了几微秒而牺牲可读性是没有必要的。
   2. 指针式常量地址，拥有固定的位置，这是它与一般的指针区别之处
   3. 数组的名称可以作为参数传递，参数：char const*,或者char *。
      1. 声明函数时候也是用的指针形式

4. 初始化：静态类型的初始化：

   ```c
   int vector[5]={1,5};//合法，默认前两位
   int vector[]={1,2,3,4,5};//合法，自动计算数组长度
   char message[]="Hello";//合法，message是一个字符串常量
   ```

5. 多维数组

   ```c
   iint matrix[2][3] = { {11,12,13}, {21,22,23} };//按照顺序储存,二维数组的初始化
   *(*(matrix+1)+1)=22,matrix[1][1]=22,**(matrix)+4=22
   ```

   由于是顺序存储，因而数组名称也可以看作是一个指针，用指针去间接访问也是可行的。

   访问其中的元素需要两个**执行——内层对应第一个[]，外层对应第二个[]。

   * 二维数组是指向指针的指针，因而才需要两个取值符号
   * 二维数组作为函数参数应该怎么使用？
   * `void func(int mat[][3])`或者`void func(int (*mat)[10])`
   * 第一个括号种包含的本质上是“数组的个数”，第二个括号中的数字是储存的上限，其计算方法是n*sizeof(type);顺带一提，字符串的储存需要多一个‘0’的阶数为
   
   ```c
   char const* keyword[] = {
   "do","for","if","register","return","switch","while",NULL
   };
   char const keyword2[][9] = {
   "do","for","if","register","return","switch","while"
   };//注意区别两种方式的不同，前者创建的是一个“查询表”指针数组，后者则是一个“表格”
   ```
   
   编程练习——矩阵乘法：难点在于传入参数为一个数组——
   
   ```c
   编译器好像允许 int *ap = vector,vector是二维数组名，所指向的是二维数组的第一个数字地址
   int (*ap)[3] = vector这样比较好，或者 int *ap = matrix[0]
   ```
   

___



### Chapter 9 字符串、字符和字节

1. ```c
   size_t strlen(char const *string);\\计算数组长度
   char *strcpy(char *dst,char const *src);\\把参数src复制到dst中去
   char *strcat(char *dst,char const *src);\\连接两个字符串（返回值是前一个）
       \\两者返回值是第一个参数的副本，但是可读性上不推荐
   int strcmp( char const *sl ,char const *s2);\\比较两个字符串的值
   
   \\为了防止溢出，有些函数会要求输入字符串的长度
   
   ```



___

### Chapter 10 结构和联合

1. 结构 Struct

```c
//声明
struct tag {member_list} variable-list;
```

访问结构体使用指针，采用

指向结构的指针->变量名；

或者：

结构名.变量；

来访问

```c
typedef struct{List}Ex; \\用来定义一类struct，好处在于定义它的变量时候少些一个struct
Ex x={按照list初始化};
```

* 位段：
  * bit field

2. 联合 Union

   声明：

   ```c
   union {List}name;
   ```

   其中的元素公用一个空间——既可以作为一种又可以作为另一种输出——每次写入会覆盖另外一个的空间

   用于用最小的空间储存AorB类型的值

___

### Chapter 11 动态内存分配 

1. 为什么使用动态内存分配？更加灵活与“可编程”的空间分配（我的理解）
2. 

```c
void malloc(size_t size);
//size_t是一个无符号定义,分配的空间是连续的
// 在请求内存不够时候会返回NULL
//返回一个空的指针
void free(void *pointer);
void *calloc(size_t num_elements,size_t element_size);
//分配内存，会在初始化的时候把它初始化为0
void realloc(void *ptr, size_t new_size);//修改一个原先分配好的内存块的大小
```

___

### Chapter 12 使用结构和指针（与网课内容重叠）

1. 链表

### Chapter 13 高级指针话题

1. 指向指针的指针

   因为变量名的“未知”与不确定，而指向指针的指针可以解决

2. 高级声明

3. 函数指针

   `int f(int);int (*pf)(int)=&f`声明了一个函数指针

   应用：回调函数；转移表

4. 命令行参数 `mian(int argc, char **argv)`

   后者用于存储文件信息，前者存储 `argv` 中实际传递了多少参数

   



___



### Chapter 14 预处理器

1. 预处理（preprocessing）是编译C程序的第一个步骤。

2. 预处理符号，包含了文件的编译信息（时间、日期、文件名等等）

3. #预编译符号
   1. #define 用于把**任何文本**替换到程序中
   
4. #define中能够加入参数

   1. ​	##可以把一个值添加到变量名中

   2. 宏能够代替一些简单的函数，可以减小一些运算量，而且不受数据类型的限制

   3. ```C
      #define MAX(a,b) ((a)>(b)?(a):(b))
      #include<stdio.h>
      
      int main(void) {
      
      	int x = 5, y = 6, z;
      
      	z = MAX(x++, y++);
      
      	printf("x=%d,y=%d,z=%d",x,y,z);
      	return 0;
      }
      输出：x=6,y=8,z=7
      原因：1、在于直接替换；2、++在后是返回原值后加一
      ```

   4. 由此，变量在进入宏定义的“函数”中后，本身是不会被保护的，因而很可能会改变值

   5. 为了区分两类函数，一般约定用全大写的命名方式来定义宏的函数

   6. `#undef name` 可以移除一个宏

5. 有些编译器允许在命令行中定义符号

6. 条件编译

   ```
   #if constant-expression
   		statement
   #elif ...
   #else ...
   #endif
   ```

   用于达成“某种条件下”才进行编译。这个语法可以嵌套

7. 文件包含

   1. <>和""编译器会区别处理

8. 其它的一些指令：

   1. `#error`可以产生一条错误信息；#line允许用户修改\_\_LINE\_\_

      `#progma`允许编译器提供不标准的处理过程



___

### Chapter 15 输入/输出函数



#### 错误报告和终止

`void perror(char const *message);`可以抛出异常信息

`void exit( int status);`可以主动终止程序

#### 标准I/O

为了解决操起编译器的函数库输出输入方面的不足而诞生，ANSI C是增进了移植功能后的标准库后代，使用不同的函数方式实现。

 `stdio.h`包含了与ANSI C有关的声明，

1. 流：从程序溢出字节，这种字节流称为“流”；通过缓冲区来“读取”和“写入”

   文本流、二进制流

2. 文件

   FILE结构

   `fopen()`函数用来打开流，把一个流和文件相关联；`fclose()`来关闭流

3. 字符I/O

   `getchar();putchar()`用于字符串

___

### Chapter 16 标准函数库

#### 整型函数

1. `<stdlib.h>`:

   算术：包含了加减乘除；

   随机数:包含了随机数生成

   字符串转换为数值（可以返回浮点数类型）

#### 浮点型函数

1. `math.h`

   三角函数、双曲函数、对数和指数函数、浮点数表示形式、幂、底数、顶数、绝对值和余数

#### 日期和时间函数

1. `time.h`

   处理器时间、当天时间、日期和时间的转换、

2. `<setjmp.h>`

   非本地的跳转

#### 信号

1. `signal.h`

   信号：一种事件，有可能异步发生，需要一个专门的事件处理函数。

2. `stdarg.h`:

   打印可变参数列表

#### 执行环境

1. `stdlib.h`:终止、断言、环境、系统命令、`qsrot`（二分查找）

#### locale

1. `locale.h`

   数值和货币格式化

___

### Chapter 17 经典抽象数据类型

ADT 是用来获取内存，存储值

#### 堆栈

1. 接口：`push pop`
2. 形式：动态、静态和

#### 队列

1. 接口：

#### 树



### Chapter 18 运行时的环境

如何通过程序来判断编译器的环境：需要使用C语言和汇编语言的接口



