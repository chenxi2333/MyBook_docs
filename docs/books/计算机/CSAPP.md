# 深入理解计算机系统

## Chapter1 计算机系统漫游

## Chapter2 信息的表示和处理

1. 基于二进制的表示的计算机系统。

   1. 不同位数、不同架构的系统中C语言的中类型是由不同的长度的，比如long在32位系统里4字节，在64位系统中8字节。

   2. 16进制的意义是能够做到“4个2进制”直接组合，便于书写 观察。

   3. 位数的含义是地址的位数。

   4. 选择二进制的重要原因就是bool运算。

      1. 按位操作是C语很重要的功能。单个的| & ~ ^(或、与、非、异或运算符号)
         1. &又被称为mask，因为可以便捷的做到“遮掩”，留下遮掩运算中1的位。
      2. 注意与|| && !的区分，双符号是数值本身的真假判断，只有0是False，返回只有0和1。
      3. 按位运算——左移和右移。
         1. Log<<和>>:多出来的位会填充0。
         2. Arith.>>和.<<：多出来的位填1。
         3. 大于等于字长、或者小于0的移动通常被判定为非法。
   
   5. 二进制数字和不同数据类型的转换方法：
   
      1. 无符号数可以直接幂求和。有符号数采用了补码编码。
   
      2. 有符号数可以看作是最高一位的幂运算取负数，其它位数全部求和。其实也很好理解——如果第一位是1，那么就从负数开始计数，加上后面位数的数值；如果第一位是0，就从0开始正常计数——这个第一位被称为是符号位。
   
         1. 因此符号数的0不是正负的“连接处”。全部1，则可以得到-1。
   
         2. 如果让人去判断：第一个数判断正负，如果是1，负数，后面的数取反+1后就是这个负数的绝对值。由于0只有一个，并且算在了“正数”中，因此负数会比正数“多一个”。
   
         3. 有符号数（Two's Complement）和无符号(Unsigned)数的转换：可以转化成二进制然后再转化。
   
            1. T2U：如果第一位是1就直接加上最高一位的2次幂2^W，如果是0则不用改变。
            2. TMAX*2+1=UMAX
   
         4. C语言是少数能够明确的使用“unsigned”的语言。
   
            1. C语言能够在unsigned和signed之间隐式转换，如果两者中有一个无符号，那么会把另外一个自动转化成为无符号数。在数字后面加一个u，说明这是一个无符号数。
   
            2. (int)(unsigned)属于更高的强制类型转化，可以把一个数做类型转换。
   
               > -1>0U ; 2147483647U< -2147483647-1，这两者都是因为自动把负数转化成了无符号数进行的比较。
               >
               > 2147483647 > (int)2147483648U，两个有符号数，后者自动转化成了-1。
               >
               > (unsigned)-1> -2 ,两者自动转化成了无符号数，相当于是4,294,967,294>4,294,967,293
   
            3. > for(i=n-1;i>=0;i--)这句话中如果i是unsigned，那么循环将会永远进行下去——因此i到零之后继续-会得到UMAX，如果循环中使用到了数组索引，则会报超出数组上限的错误。当然，如果使用的是有符号数，就不会出现这个错误。 
   
   
   > 有符号数另外两种表示方法是反码（负数从零开始）和原码（符号位仅仅表示符号）,这两种方式中都存在-0这个数[10000...]
   
   1. 拓展Extension：一个数拓展位数的时候怎么改变
      1. 无符号数：zero extension
      2. 补码：符号拓展sign extension
         1. 第一位取出，放到最开始，其他位数补0。0的话到此就可以了
         2. 如果是负数，首位为1，那拓展出来的位数补1。
         3. 总结，把第一位复制k份，补充到拓展的位数上。
      3. 在C语言的拓展操作上，长度和符号的转换一般先进性符号和无符号之间的转换，再进行字长的拓展。 
   2. 截断Truncating：符号数的位数缩短会发生什么？无论是哪一种数，截断都是直接丢弃最高的位，因此很容易改变值。
   
      1. unsigned直接弃最高位。相当于是原来的值对截断的最低位2^k进行的一次“取模运算”。很容易理解，取模运算就是“不超过这个数字的部分”。
      2. signed：补码截断可以先转化为无符号数，取模，然后再转化为符号数。

### 整数运算

1. 无符号数加法：直接相加，进位，超出之后将会溢出。溢出后得到的结果就是结果对最大数$2^w$取模后的结果。
   1. C语言对无符号数的溢出不会有提示，但可以检测是否溢出。
      1. 基本思路：因为无符号数大于0，相加的结果一定是高于原本的数值的，如果溢出，则一定会小于原先的数值。
2. 补码相加：补码的特性让它的加法可以做到直接相加，需要注意的只有溢出的情况将会导致符号的错误。
   1. 补码计算中的溢出的符号位有时候可能只是正常的符号转换。只要结果能够在范围内，就不会出现计算错误。
   2.  溢出只发生在结果超过TMAX和TMIN的情况下。
   2.  可以观察结果的符号是否出现了颠倒——如两个负数加出正数或者相反的情况，则说明溢出了。只要符号正确，都代表了结果是正常的。这也是用来检测溢出的一般方法。
3. 乘法：同样会遇到溢出。
   1. 无符号数乘法：超过上限则进行取模运算。
   2. 有符号数：相乘后同样使用截断。可以把结果转化成无符号数，截断后再转化成为有符号数。
   2. 位级等价性：**同样的编码，无论是补码还是无符号数，即使相乘完整的（2w位的位级表示）结果不同，但是经过截断后的结果编码（位级表示）永远是一样的。**
4. 一般来说计算机乘以2的幂会使用左移。
   1. 这一点对于有符号数和无符号数都适用。 只要一个有符号数乘法过后不会溢出，那么左移运算是能够保证正确性的。
   2. 能用位移做运算对于编译器是最快速的——是需要一个时钟周期。
5. 同理，对2的幂进行除法可以右移。
   1. 算数右移可以用1填充空余位，可以用来计算补码有符号数的负数除法。（Java中的右移当作是算数右移）
6. 一个数字取反数的计算方法：
   1. 补码按位取反然后+1；unsigned=2^w-x(x!=0) 。
   2. Tmin的取反+1将会得到的数由于溢出，因此只能够得到它本身，即TMIN。——因此-x==x是可能存在的情况

7. 递减：对于Unsigned，0-1->UMax。



### 机器字长

1. 储存上区分：大端序、小端序（常用）。小端序它的字节（8bit）是倒过来排的。
2. 因为char只有8位，因此顺序永远是对的。



### Floating Point浮点数

1. 小数同样使用2^(-x)来表示。这种计数方法没办法准确表示每一个小数，限制很多。
   1. 由于早期浮点数表示的标准并不统一，非常麻烦，IEEE Floating Point标准进行了统一。
2. 目前的浮点数表示方法：符号位s+阶码exp+尾数frac $v=(-1)^sM2^E $
   1. 32bits:1+8+23
   2. 64bits:1+11+52
   3. 以2为底数的幂计算，就是在M的基础上进行左右移动。
   4. 这种计数法可以让数据密集程度

3. 浮点数的加法：不可结合的特性
4. round：舍入：向上舍入、向下舍入、向零舍入。要看舍到哪一位。
   1. 二进制的舍入：0舍1入。
5. C语言的浮点数：float double
   1. int到double的互相变化，可以完全转化，整数部分能够完全放得下。但是到float就会舍去部分的数。