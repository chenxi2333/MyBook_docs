# 深入理解计算机系统

## Chapter1 计算机系统漫游

## Chapter2 信息的表示和处理

1. 基于二进制的表示的计算机系统。

   1. 不同位数、不同架构的系统中C语言的中类型是由不同的长度的，比如long在32位系统里4字节，在64位系统中8字节。

   2. 16进制的意义是能够做到“4个2进制”直接组合，便于书写 观察。

   3. 位数的含义是地址的位数。

   4. 选择二进制的重要原因就是bool运算。

      1. 按位操作是C语很重要的功能。单个的| & ~ ^(或、与、非、异或运算符号)
         1. &又被称为mask，因为可以便捷的做到“遮掩”，留下遮掩运算中1的位。
      2. 注意与|| && !的区分，双符号是数值本身的真假判断，只有0是False，返回只有0和1。
      3. 按位运算——左移和右移。
         1. Log<<和>>:多出来的位会填充0。
         2. Arith.>>和.<<：多出来的位填1。
         3. 大于等于字长、或者小于0的移动通常被判定为非法。
   
   5. 二进制数字和不同数据类型的转换方法：
   
      1. 无符号数可以直接幂求和。有符号数采用了补码编码。
   
      2. 有符号数可以看作是最高一位的幂运算取负数，其它位数全部求和。其实也很好理解——如果第一位是1，那么就从负数开始计数，加上后面位数的数值；如果第一位是0，就从0开始正常计数——这个第一位被称为是符号位。
   
         1. 因此符号数的0不是正负的“连接处”。全部1，则可以得到-1。
   
         2. 如果让人去判断：第一个数判断正负，如果是1，负数，后面的数取反+1后就是这个负数的绝对值。由于0只有一个，并且算在了“正数”中，因此负数会比正数“多一个”。
   
         3. 有符号数（Two's Complement）和无符号(Unsigned)数的转换：可以转化成二进制然后再转化。
   
            1. T2U：如果第一位是1就直接加上最高一位的2次幂2^W，如果是0则不用改变。
            2. TMAX*2+1=UMAX
   
         4. C语言是少数能够明确的使用“unsigned”的语言。
   
            1. C语言能够在unsigned和signed之间隐式转换，如果两者中有一个无符号，那么会把另外一个自动转化成为无符号数。在数字后面加一个u，说明这是一个无符号数。
   
            2. (int)(unsigned)属于更高的强制类型转化，可以把一个数做类型转换。
   
               > -1>0U ; 2147483647U< -2147483647-1，这两者都是因为自动把负数转化成了无符号数进行的比较。
               >
               > 2147483647 > (int)2147483648U，两个有符号数，后者自动转化成了-1。
               >
               > (unsigned)-1> -2 ,两者自动转化成了无符号数，相当于是4,294,967,294>4,294,967,293
   
            3. > for(i=n-1;i>=0;i--)这句话中如果i是unsigned，那么循环将会永远进行下去——因此i到零之后继续-会得到UMAX，如果循环中使用到了数组索引，则会报超出数组上限的错误。当然，如果使用的是有符号数，就不会出现这个错误。 
   
   
   > 有符号数另外两种表示方法是反码（负数从零开始）和原码（符号位仅仅表示符号）,这两种方式中都存在-0这个数[10000...]
   
   1. 拓展Extension：一个数拓展位数的时候怎么改变
      1. 无符号数：zero extension
      2. 补码：符号拓展sign extension
         1. 第一位取出，放到最开始，其他位数补0。0的话到此就可以了
         2. 如果是负数，首位为1，那拓展出来的位数补1。
         3. 总结，把第一位复制k份，补充到拓展的位数上。
      3. 在C语言的拓展操作上，长度和符号的转换一般先进性符号和无符号之间的转换，再进行字长的拓展。 
   2. 截断Truncating：符号数的位数缩短会发生什么？无论是哪一种数，截断都是直接丢弃最高的位，因此很容易改变值。
   
      1. unsigned直接弃最高位。相当于是原来的值对截断的最低位2^k进行的一次“取模运算”。很容易理解，取模运算就是“不超过这个数字的部分”。
      2. signed：补码截断可以先转化为无符号数，取模，然后再转化为符号数。

### 整数运算

1. 无符号数加法：直接相加，进位，超出之后将会溢出。溢出后得到的结果就是结果对最大数$2^w$取模后的结果。
   1. C语言对无符号数的溢出不会有提示，但可以检测是否溢出。
2. 补码相加：补码的特性让它的加法可以做到直接相加，需要注意的只有溢出的情况将会导致符号的错误。
   1. 补码计算中的溢出的符号位有时候可能只是正常的符号转换。只要结果能够在范围内，就不会出现计算错误。
   2.  溢出只发生在结果超过TMAX和TMIN的情况下。
3. 乘法：同样会遇到溢出。
   1. 无符号数乘法：超过上限则会被取模运算。
   2. 有符号数：溢出可能会有符号错误。
   3. 一般来说计算机乘以2的幂会使用左移。
      1. 这一点对于有符号数和无符号数都适用。 只要一个有符号数乘法过后不会溢出，那么左移运算是能够保证正确性的。
      2. 能用位移做运算对于编译器是最快速的——是需要一个时钟周期。
4. 同理，对2的幂进行除法可以右移。
   1. 算数右移可以用1填充空余位，可以用来计算补码有符号数的负数除法。（Java中的右移当作是算数右移）
5. 一个数字取负数的计算方法：按位取反然后+1。
   1. Tmin的取反+1将会得到的数由于溢出，因此只能够得到它本身，即TMIN。——因此-x==x是可能存在的情况
6. 递减：对于Unsigned，0-1->UMax。



### 机器字长

1. 储存上区分：大端序、小端序（常用）。小端序它的字节（8bit）是倒过来排的。
2. 因为char只有8位，因此顺序永远是对的。