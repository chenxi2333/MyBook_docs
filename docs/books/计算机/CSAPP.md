# 深入理解计算机系统

1. 基于二进制的表示的计算机系统。

   1. 不同位数、不同架构的系统中C语言的中类型是由不同的长度的，比如long在32位系统里4字节，在64位系统中8字节。

   2. 16进制的意义是能够做到“4个2进制”直接组合，便于书写 观察。

   3. 位数的含义是地址的位数。

   4. 选择二进制的重要原因就是bool运算。

      1. 按位操作是C语很重要的功能。单个的| & ~ ^(或、与、非、异或运算符号)
      2. 注意与|| && !的区分，双符号是数值本身的真假判断，只有0是False，返回只有0和1。
      3. 按位运算——左移和右移。
         1. Log<<和>>:多出来的位会填充0。
         2. Arith.>>和.<<：多出来的位填1。
         3. 大于等于字长、或者小于0的移动通常被判定为非法。

   5. 二进制数字和不同数据类型的转换方法：

      1. 无符号数可以直接幂求和。

      2. 有符号数可以看作是最高一位的幂运算取负数，其它位数全部求和。其实也很好理解——如果第一位是1，那么就从负数开始计数，加上后面位数的数值；如果第一位是0，就从0开始正常计数——这个第一位被称为是符号位。

         1. 因此符号数的0不是正负的“连接处”。全部1，则可以得到-1。

         2. 如果让人去判断：第一个数判断正负，如果是1，负数，后面的数取反+1后就是这个负数的绝对值。由于0只有一个，并且算在了“正数”中，因此负数会比正数“多一个”。

         3. 有符号数（Two's Complement）和无符号(Unsigned)数的转换：可以转化成二进制然后再转化。

            1. T2U：如果第一位是1就直接加上最高一位的2次幂2^W，如果是0则不用改变。
            2. TMAX*2+1=UMAX

         4. C语言是少数能够明确的使用“unsigned”的语言。

            1. C语言能够在unsigned和signed之间隐式转换，如果两者中有一个无符号，那么会把另外一个自动转化成为无符号数。在数字后面加一个u，说明这是一个无符号数。

            2. (int)(unsigned)属于更高的强制类型转化，可以把一个数做类型转换。

               > -1>0U ; 2147483647U< -2147483647-1，这两者都是因为自动把负数转化成了无符号数进行的比较。
               >
               > 2147483647 > (int)2147483648U，两个有符号数，后者自动转化成了-1。
               >
               > (unsigned)-1> -2 ,两者自动转化成了无符号数，相当于是4,294,967,294>4,294,967,293

            3. > for(i=n-1;i>=0;i--)这句话中如果i是unsigned，那么循环将会永远进行下去——因此i到零之后继续-会得到UMAX，如果循环中使用到了数组索引，则会报超出数组上限的错误。当然，如果使用的是有符号数，就不会出现这个错误。 
   
   6. Sign Extension：一个符号数拓展位数的时候怎么改变
   
      1. 第一位取出，放到最开始，其他位数补0。0的话到此就可以了
      2. 如果是负数，首位为1，那拓展出来的位数补1。
      3. 总结，把第一位复制k份，补充到拓展的位数上。
   
   7. Truncating：符号数的位数缩短会发生什么？
   
      1. unsigned直接弃最高位。相当于是一个“取模运算”。
      2. signed：类似于mod的