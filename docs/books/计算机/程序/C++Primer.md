# 《C++ Primer》

1. **C++与C有什么不同？有什么独特的特点？**

   一言以蔽之：强大的抽象能力——面向对象的编程+泛型编程的支持。

   ​	C++11为这门语言带来了新的变化，使之能够更加简洁。

   ​	本次的（2011）改动相比98包括了更加统一的语言，标准的库更加简单高效，可以更高效编写。

   ​	C++包括了三个部分：C语言的基础+高级语言特性+标准库。

2. **为什么要学C++？有什么是必须要C++才能做的？**

   C++拥有C语言的底层和面向对象的特性，作为一门入手计算机学科的语言非常合适。必须要能够静下心去学习。

3. **编程环境配置**

   使用VS Code进行编程,配置的编译器用的是MinGW，开源并且好用。

   步骤具体见：[VSCode配置C/C++环境 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/87864677)

   练习了在命令行中进行编译，直接用命令`gcc -o 1 1.cpp`就可以生成`1.exe`(在Linux中没有exe的后缀),使用`.\1`就可以成功运行。

4. **如何学好编程？**

   多写代码，把每一个例题都做一下，搞懂。每一周把所学的内容进行整理总结，用尽量简洁的语言在这个文档中进行复述。



# Chapter1-开始

本章的主要内容是介绍了C++的基本语法和功能，包括了标准库的输入和输出、基本的语法（注释、循环和条件控制流）、面向对象的编程基础（类和成员对象）。本章在例题的带领下完成了一个书店的程序，通过调用一个类`Sales_item`编写了一个书店程序。

1. 标准输入和标准输出

   包含于ostream下的std库，同一个库中不能出现重名的类。

   `cin`:标准输入类，连接输入的缓冲区域，从输入设备或者输入的流中获取值，可以看作一个函数了，返回值就是输入的值。如果输入值为结束符或者错误值返回0。

   `>>`：输入运算符，表示从左侧的std对象获取数值赋值给右侧。

   `cout`:标准输出类，打印出获得的值。

   `<<`:输出运算符，能够把右侧的值赋予给左侧的std对象。

   `endl`：结束运算符，相当于C语言中的`\0`，用来结束一次输出。

   > 输入和输出运算符都遵循左侧优先的运算顺序，cout>>value1>>value2 等价于 (cout>>value1)>>value2，效果就是连续输出两个数值。

​	初次之外还有`cerr clog`对象也是标准输出中的，用来输出错误信息和文本

2. 注释

   C++中的注释沿用C语言中的，`//`和`/* */`第二种用于多行的注释，虽然没有明确的要求，但是习惯于会在每一行的开头加上一个*来表明这部分是注释。

   编译器能够识别注释并且不会编译，编译器除了负责编译也能查找错误（包括语法错误、类型错误、声明错误等）。

   C++很大程度上格式自由，对于缩进没有严格要求，不过一般为了美观可读，都会对格式上有约定俗成的要求。

3. 控制流：while和if与C语言一样

   `++value`等价于`(vlaue=value+1)`，由于是有限运算，一般都是优先使用。`value++`这种写法是先返回原来值再加一，一般不会用。

4. 类

   C++面向对象的主要部分，每个类都是一种新的数据类型，而类的定义则对对象的行为做出了规定——包括：成员函数（方法）、对类的对象进行赋值和运算符号代表了什么含义等等。



# Chapter2-变量和基本类型



## const限定符

- const的作用是定义静态对象。对于不需要改变值或者不想改变值的变量，我们赋予const属性
- 常见用法：定义固定大小的缓冲区大小变量

1. 初始化：

   1. const对象只能够且必须在初始化的时候赋值
   2. 其余的方面和普通对象类似

2. const仅在同一个文件中生效

   1. 想要跨文件调用，可以在每个对于它的声明和定义之前都添加extern。
   2. 编译器本质上用的还是“替换”。因此

3. const的引用——又被称为“对常量的引用”

   1. 将引用绑定到一个const对象上，这个引用也必须是常量的
   2. `const int ci=1 ; const int &r1=ci`
   3. 但是常量引用可以引用一个非常量的对象或者表达式，这个过程本质上其实是编译器弄了一个临时变量做了一下转换。
      1. 这个没什么用，只是一个例外——常量引用的类型和对象可以不一致。不过由于是临时变量，因此不会影响。
      2. 不能够通过这个绑定的常量引用修改原来非常量对象的值。

4. 指针和const：指向常量的指针。

   1. 必须区分“指向常量的指针”和“常量指针（指针本身是一个常量）”

   2. 指向常量的指针，不能改变其值；

      1. `const int *cptr=&pi`这种写法是指向常量的指针。
      2. 可以理解成“指针指向`const int`”这种类型，就是说指针是指向常量的。
      3. “指向常量的指针”也可以指向一个“非常量的对象”；

   3. 常量指针：意味着指针本身的地址指向无法被改变，但是被指向的对象值可以改变

      1. 常量指针必须初始化`int *const cptr = &errNumb`。
      2. 可以理解为const修饰的是指针*符号——因为\*和数据类型一样，本质上也是一种复合数据类型。

   4. 顶层const（常量指针）：用来表示指针本身是一个常量；

      相对，底层const（指向常量的指针）则表明所指对象是一个常量。

      1. 一个指针可以既是顶层又是底层

   5. 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。

      1. constexpr常量：是一个前缀修饰符，C++11标准中规定的声明的变量一定是一个常量，且必须初始化。
      2. 字面值类型
      3. 指针和constexpr


## 处理类型

1. 类型别名typedef：
   1. using也可以用来做别名声明
   2. 和复合类型（指针、常量等）组合使用有很多效果
2. auto类型说明符：
   1. 让编译器推算表达式对应的数据类型，代替int之类的数据类型，自动生成
   1. `auto item = val1 + val2`,不过同一句中的auto不会变成不一样的类型。
   1. auto能够自动生成顶层const。引用之前的类型也可以用auto
3. decltype类型指示符：
   1. 类型说明符，作用是选择并返回操作数的数据类型。有点类似于一个函数。
   2. `decltype(ci) x=0; `表明x和ci是同一种数据类型。
   3. decltype中间可以包含表达式


## 自定义数据结构

1. 定义struct
   1. struct 方法，包含了数据类型，所定义的是数据成员。虽然算不上类，但是也是一种自定义数据结构。
   2. struct用法和C语言类似。`struct Name{}name1,name2`
   3. 类可以提供初始值。

2. 使用struct
   1. 和C语言用法类似。

3. 编写头文件
   1. 头文件通常包含了只定义一次的实体。
   2. 预处理器：能够确保头文件多次包含仍旧安全工作。#ifdef是头文件按保护符。

4. 

# Chapter3-字符串、向量和表达式

本章的主要内容是介绍标准库中最重要的两种类型：string和vector

## 命名空间的using声明

`using namesapce::name；`可以用于声明命名空间中的某个类。这样的话在使用的时候不需要使用`::`来说明作用域。

- 每个名字都需要**独立**的using声明
- 头文件不应该包含using
  - 原因是可能造成不必要的名称冲突

## 标准库类型string

1. string是一个类，因此使用类的初始化就可以。

   书上介绍了初始化的几种方式，两种方法也可以混用。

   1. 直接初始化（用括号方法）
   2. 拷贝初始化（用=赋值）

2. string对象操作

   1. 读写
      1. 使用getline读取一整行
   2. empty和size操作
   3. `string::sizetype`类型
      1. 它是在string中定义的一种类，用于在不同的环境下正确显示字符串的长度
   4. 比较`== != > <`
      1. 规则：第一对相异的字符比较大小
   5. 赋值
   6. 相加：规则是直接相连，但是必须确保两侧至少各有一个string 的对象
      1. "xxx"不是string对象。是一个字符串常量。为了与C兼容做出的让步。

3. 处理string中的字符

   这类问题一般包含两个方面：一是循环字符串中的每一个变量，另外一个是处理其中的字符。

   1. 第二个问题cctype中提供了一些方法可以处理和判断字符。

   2. C++新的标准提供了新的for循环遍历方法。可以用在全部遍历的处理上

      `for(auto c:s){}`：之前是一个临时变量，用于访问：后的序列，每次迭代变量会取到一个新的值。

      想要改变的话c需要使用引用，这样的话这个值不再是临时存放迭代值的地方，而是实际上“成为”了这个迭代部分。

   3. 部分字符处理的方法：

      1. 下标：字符串[string::size_type]的方法可以访问字符串的某一个值
      2. 迭代器：下标+迭代器的使用
         1. 部分的访问；有条件（更改循环条件即可）；随机访问

## 标准类型库vector

标准库vector表示对象的集合，是一个用于容纳其他类型的对象的“容器”。

vector是一个类模板——对于不同类型的对象需要使用不同“种类”的容器。

1. 定义和初始化对象`vector<T>`
   1. 普通方法
   2. 列表初始化vector对象
   3. 创建指定数量的元素
   4. 值初始化：
      1. `vector<T> v1(10,1),v2{10,1}`分别是指10个1；10和1两个元素
      2. 字符串的初始化只能够使用{}括号

2. 添加元素
   1. 类似于队列的添加方式，可以高效的在队列里增加元素
   2. `push_back()`
   3. 但是注意：for循环遍历的序列大小不能改变

3. 其他操作
   1. vector同样支持下标[]操作
   2. 下标元素不能够用来添加元素。空的vector不能够用下标访问。


## 迭代器

1. 迭代器可以用来访问容器类型中的对象。迭代器提供了对于对象的间接访问。
2. 使用迭代器：迭代器的本质上还是类似于指针的。
   1.  begin和end是两个指针，分别指向容器的开头和“尾后”。
   2.  迭代器运算符：基本和指针类似。*iter获取指向的值
   3.  将迭代器从一个元素移动到另外一个元素：直接增加就可以了，auto能够自动适应类型。
   4.  auto关键词是很好的，对于迭代器的实际类型应该是这种：`vector<int>::iterator`，auto能够自动对初始化的对象寻找合适类型，节省很多错误。它让C++看起来更像是动态语言。
   5.  cbegin和cend:指向常量的指针。
   6.  结合解引用和成员访问操作：所指向的对象有成员的时候可以使用解引用
       1. `iter->empty()`等价于`(*iter).empty()`
   7.  某些对vector对象的操作会让迭代器失效，比如改变容器的长度。
3. 迭代器运算：本质上还是类似于指针运算
   1. 算术运算：移动指针
   2. 使用迭代器运算：在计算例如二分搜索的时候很方便
      1. 注意的是，两个迭代器之间只有相减的运算而没有相加的运算。返回的是迭代器之间的“距离”——一个特殊的有符号的数据类型



## 数组

1. 数组是沿用自C语言的数据结构。数组大小不变，牺牲了一定的灵活性，但有时候性能更好。
2. 定义数组：
   1. `int *parr[size]`size必须是常量。数组的元素被默认初始化0。
   2. 数组也是对象的容器，不允许使用auto进行推断
   3. 显式初始化
   4. 字符的数组初始化允许直接使用一串字符串常量（自动添加结束空字符）
   5. 初始化不允许拷贝，用其他的数组给另一个赋值
   6. **重要区分**：数组的维度紧跟名字，（）相当于是把修饰符看作是名字的一部分，而不是数组类型了。
      1. `int *pr[10]`是指针的数组；`int (*pr)[10]`是指向int数组的指针。
      2. `int &pr[10]`是错误的，引用不是对象；`int (&pr)[10]`是int数组的引用
3. 访问数组元素
   1. 下标访问——本质上是对指针取值操作。
   2. 对指针解引可以获取值。
   3. 因此和对象索引的下标不同的是，数组的下标可以是负值——对应指针的前移。
4. 指针和数组：
   1. 使用数组的时候编译器一般会把它自动转化成指针。数组本身和C里面一样，大多数时候是指向数组首元素的指针。
   2. 因此数组的操作方法更多时候类似于指针。和迭代器操作也类似。
   3. 数组也有begin和end，不过由于数组不是对象，因此begin和end也是以函数的形式完成的。
      1. `begin(ia);end(ia)`返回值是指针，分别指向数组的开头和尾后。
      2. 这两个函数定义在标准库的iterator头文件中，使用时候需要引用。
5. 指针运算：和迭代器基本一样。意义也相同。
6. C风格字符串：尽量不要使用，是C语言标准库中提供的对C的字符串(`char str[]`这种)进行操作的一些方法。
   1. 用String类型就可以完成的操作和运算，在C语言中只能借助对应函数完成。
   2. 留下这个接口是用来给C语言提供一些衔接。通常可以用C字符串给C++赋值，但是反过来就不行。
      1. `char *str = s.c_str();`这个函数用来转换为C风格的字符串。
      2. `vector<int> ivec(begin(arr),end(arr))`可以把数组转化为vector。
   3. 不过还是建议尽量使用标准库类型而不要使用数组、

## 多维数组

1. 严格来说，C++没有多维数组，一般来说是C中数组的数组。

2. 初始化

3. 下标引用

   1. 使用for循环处理多维数组

4. 指针和多维数组

   1. 如何通过指针遍历数组？外层遍历内层数组的指针，外层指针取值获取内层数组的指针，再通过遍历内层指针访问指针指向的对象。
   2. 可以通过begin和end函数访问内层函数的开头和结尾。

5. 类型别名可以简化一些理解的工作。

   1. `using int_array = int[4];`

      `typedef int int_array[4];`二者等价，都是将int_array定义为4个整数的数组。



# Chapter4-表达式

## 基础

1. 基本概念

   - 表达式，expression,由一个或者多个运算对象组成，对表达式求值将得到一个结果。
     - 字面值和变量本身就是最简单的表达式。
     - 用运算符连接多个运算对象组成复杂的表达式

   - 运算符：一元运算符、二元运算符（根据作用的对象），函数也是一种运算符
     - 组合运算符和运算对象：运算优先级
     - 不同的对象之间运算会自动进行一些简单的数据转换
     - 重载运算符：用户可以自行为一些内置的运算符赋予另外一层含义。

   - 左值和右值（lvalue & rvalue）：
     - 理论上感觉挺复杂的，在实践中自己判断就知道了。简单说就是一个对象在左右值时候是不一样的。左值在乎对象的地址，右值注重对象的值。
2. 优先级和结合律：

   1. 括号无视优先级和结合律。
   2. 为了确保程序正确性和可读性，多用点括号不会死。
3. 求值顺序

   1. 优先级规定了运算对象的组合方式，但是具体的求值顺序在大多数的情况下是没有指定的。

## 运算符

1. 算术运算符：加减乘除。
2. 逻辑关系运算符：比较和与或非关系
3. 赋值运算符：一定是一个可修改的左值。
   1. 对于类型来说，赋值运算的细节由类决定
   2. 赋值运算满足右结合，简单说就是从右向左。
   3. 赋值优先级较低。
   4. 复合赋值：赋值和运算结合，比如+=这种
4. 递增和递减运算符：
   1. 前置版本先加后返回，后置版本先返回后加。
   2. 非必要时候尽量使用前置。C语言其实也一样，不过C++再前置的时候不会像C语言一样对原来的值进行拷贝操作。
   3. 递增运算符号优先级高于指针解引。
      1. `*pbeg++`等价于`*(pbeg++)`。这样的写法非常常见，要能够一眼理解。
   4. 尽量不要再一个表达式中多次使用同一个会再表达式中变化的值。因为求值顺序的不确定。
5. 成员访问运算符：
   1. `(*p).size()`和`p->size()`等价。都是使用成员对象的size成员的方法。
6. 条件运算符：
   1. `cond1？expr1:expr2`语句，含义是判断真值，若为真则返回表达式1，否则返回表达式2。相当于是一个简化版的if-else语句。
   2. 嵌套条件运算符：上面那个语句可以嵌套使用。
   3. 输出表达式中可以使用条件运算符
7. 位运算符：
   1. `~ << >> & ^ |`分别是按位求反、左移、右移、位与、位异或、位或。
   2. 位移运算符会把移出边界的位舍弃
   3. 按位运算符号是单个，成双之后是逻辑运算符号。
   4. 位移运算符重载成为IO运算符，遵循向左结合律。
8. sizeof运算符
   1. `sizeof(type)`和`sizeof expr`,返回size_t类型，就是对于这个机器而言的字节数，例如char的size是1。
9. 逗号运算符
   1. 从左向右求值，连在一起作为一个表达式的时候返回右边的表达式结果。

## 类型转换

1. 表达式中存在一些类型不一致的运算，这时候会自动根据类型转换规则将对象进行“隐式转换”。
2. 算术转换：
   1. 整型提升：拓展长度来增大范围
   2. 无符号类型转化
   3. 很多时候是依赖机器的
3. 隐式类型转换：
   1. 数组转换为指针
   2. 指针转换
   3. 转为布尔类型
   4. 转换为常量
   5. 类类型定义的转换
4. 显式转换：`cast-name<type>(expression)`注意这种方法挺危险的。
   1. static_cast:任何具有明确定义的转换都可以
   2. const_cast:可以去除const性质
   3. reinterptret_cast:较低层次上的类型转化

## 运算符优先表

