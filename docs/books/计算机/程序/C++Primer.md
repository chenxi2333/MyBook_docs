# 《C++ Primer 》

1. **C++与C有什么不同？有什么独特的特点？**

   一言以蔽之：强大的抽象能力——面向对象的编程+泛型编程的支持。

   ​	C++11为这门语言带来了新的变化，使之能够更加简洁。

   ​	本次的（2011）改动相比98包括了更加统一的语言，标准的库更加简单高效，可以更高效编写。

   ​	C++包括了三个部分：C语言的基础+高级语言特性+标准库。

2. **为什么要学C++？有什么是必须要C++才能做的？**

   C++拥有C语言的底层和面向对象的特性，作为一门入手计算机学科的语言非常合适。必须要能够静下心去学习。

3. **编程环境配置**

   使用VS Code进行编程,配置的编译器用的是MinGW，开源并且好用。

   步骤具体见：[VSCode配置C/C++环境 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/87864677)

   练习了在命令行中进行编译，直接用命令`gcc -o 1 1.cpp`就可以生成`1.exe`(在Linux中没有exe的后缀),使用`.\1`就可以成功运行。

4. **如何学好编程？**

   多写代码，把每一个例题都做一下，搞懂。每一周把所学的内容进行整理总结，用尽量简洁的语言在这个文档中进行复述。



# Chapter1-开始

本章的主要内容是介绍了C++的基本语法和功能，包括了标准库的输入和输出、基本的语法（注释、循环和条件控制流）、面向对象的编程基础（类和成员对象）。本章在例题的带领下完成了一个书店的程序，通过调用一个类`Sales_item`编写了一个书店程序。

1. 标准输入和标准输出

   包含于ostream下的std库，同一个库中不能出现重名的类。

   `cin`:标准输入类，连接输入的缓冲区域，从输入设备或者输入的流中获取值，可以看作一个函数了，返回值就是输入的值。如果输入值为结束符或者错误值返回0。

   `>>`：输入运算符，表示从左侧的std对象获取数值赋值给右侧。

   `cout`:标准输出类，打印出获得的值。

   `<<`:输出运算符，能够把右侧的值赋予给左侧的std对象。

   `endl`：结束运算符，相当于C语言中的`\0`，用来结束一次输出。

   > 输入和输出运算符都遵循左侧优先的运算顺序，cout>>value1>>value2 等价于 (cout>>value1)>>value2，效果就是连续输出两个数值。

​	初次之外还有`cerr clog`对象也是标准输出中的，用来输出错误信息和文本

2. 注释

   C++中的注释沿用C语言中的，`//`和`/* */`第二种用于多行的注释，虽然没有明确的要求，但是习惯于会在每一行的开头加上一个*来表明这部分是注释。

   编译器能够识别注释并且不会编译，编译器除了负责编译也能查找错误（包括语法错误、类型错误、声明错误等）。

   C++很大程度上格式自由，对于缩进没有严格要求，不过一般为了美观可读，都会对格式上有约定俗成的要求。

3. 控制流：while和if与C语言一样

   `++value`等价于`(vlaue=value+1)`，由于是有限运算，一般都是优先使用。`value++`这种写法是先返回原来值再加一，一般不会用。

4. 类

   C++面向对象的主要部分，每个类都是一种新的数据类型，而类的定义则对对象的行为做出了规定——包括：成员函数（方法）、对类的对象进行赋值和运算符号代表了什么含义等等。



# Chapter 2-变量和基本类型



## const限定符

- const的作用是定义静态对象。对于不需要改变值或者不想改变值的变量，我们赋予const属性
- 常见用法：定义固定大小的缓冲区大小变量

1. 初始化：

   1. const对象只能够且必须在初始化的时候赋值
   2. 其余的方面和普通对象类似

2. const仅在同一个文件中生效

   1. 想要跨文件调用，可以在每个对于它的声明和定义之前都添加externl。
   2. 编译器本质上用的还是“替换”。因此

3. const的引用——又被称为“对常量的引用”

   1. 将引用绑定到一个const对象上，这个引用也必须是常量的
   2. `const int ci=1 ; const int &r1=ci`
   3. 但是常量引用可以引用一个非常量的对象或者表达式，这个过程本质上其实是编译器弄了一个临时变量做了一下转换。
      1. 这个没什么用，只是一个例外——常量引用的类型和对象可以不一致。不过由于是临时变量，因此不会影响。
      2. 不能够通过这个绑定的常量引用修改原来非常量对象的值。

4. 指针和const：指向常量的指针。

   1. 必须区分“指向常量的指针”和“常量指针（指针本身是一个常量）”

   2. 指向常量的指针，不能改变其值；

      1. `const int *cptr=&pi`这种写法是指向常量的指针。
      2. 可以理解成“指针指向`const int`”这种类型，就是说指针是指向常量的。
      3. “指向常量的指针”也可以指向一个“非常量的对象”；

   3. 常量指针：意味着指针本身的地址指向无法被改变，但是被指向的对象值可以改变

      1. 常量指针必须初始化`int *const cptr = &errNumb`。
      2. 可以理解为const修饰的是指针*符号——因为\*和数据类型一样，本质上也是一种复合数据类型。

   4. 顶层const（常量指针）：用来表示指针本身是一个常量；

      相对，底层const（指向常量的指针）则表明所指对象是一个常量。

      1. 一个指针可以既是顶层又是底层

   5. 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。

      1. constexpr常量：是一个前缀修饰符，C++11标准中规定的声明的变量一定是一个常量，且必须初始化。
      2. 字面值类型
      3. 指针和constexpr


## 处理类型

1. 类型别名typedef：
   1. using也可以用来做别名声明
   2. 和复合类型（指针、常量等）组合使用有很多效果
2. auto类型说明符：
   1. 让编译器推算表达式对应的数据类型，代替int之类的数据类型，自动生成
   1. `auto item = val1 + val2`,不过同一句中的auto不会变成不一样的类型。
   1. auto能够自动生成顶层const。引用之前的类型也可以用auto
3. decltype类型指示符：
   1. 类型说明符，作用是选择并返回操作数的数据类型。有点类似于一个函数。
   2. `decltype(ci) x=0; `表明x和ci是同一种数据类型。
   3. decltype中间可以包含表达式


## 自定义数据结构

1. 定义struct
   1. struct 方法，包含了数据类型，所定义的是数据成员。虽然算不上类，但是也是一种自定义数据结构。
   2. struct用法和C语言类似。`struct Name{}name1,name2`
   3. 类可以提供初始值。

2. 使用struct
   1. 和C语言用法类似。

3. 编写头文件
   1. 头文件通常包含了只定义一次的实体。
   2. 预处理器：能够确保头文件多次包含仍旧安全工作。#ifdef是头文件按保护符。

4. 

# Chapter3-字符串、向量和表达式

本章的主要内容是介绍标准库中最重要的两种类型：string和vector

## 命名空间的using声明

`using namesapce::name；`可以用于声明命名空间中的某个类。这样的话在使用的时候不需要使用`::`来说明作用域。

- 每个名字都需要**独立**的using声明
- 头文件不应该包含using
  - 原因是可能造成不必要的名称冲突

## 标准库类型string

1. string是一个类，因此使用类的初始化就可以。

   书上介绍了初始化的几种方式，两种方法也可以混用。

   1. 直接初始化（用括号方法）
   2. 拷贝初始化（用=赋值）

2. string对象操作

   1. 读写
      1. 使用getline读取一整行
   2. empty和size操作
   3. `string::sizetype`类型
      1. 它是在string中定义的一种类，用于在不同的环境下正确显示字符串的长度
   4. 比较`== != > <`
      1. 规则：第一对相异的字符比较大小
   5. 赋值
   6. 相加：规则是直接相连，但是必须确保两侧至少各有一个string 的对象
      1. "xxx"不是string对象。是一个字符串常量。为了与C兼容做出的让步。

3. 处理string中的字符

   这类问题一般包含两个方面：一是循环字符串中的每一个变量，另外一个是处理其中的字符。

   1. 第二个问题cctype中提供了一些方法可以处理和判断字符。

   2. C++新的标准提供了新的for循环遍历方法。可以用在全部遍历的处理上

      `for(auto c:s){}`：之前是一个临时变量，用于访问：后的序列，每次迭代变量会取到一个新的值。

      想要改变的话c需要使用引用，这样的话这个值不再是临时存放迭代值的地方，而是实际上“成为”了这个迭代部分。

   3. 部分字符处理的方法：

      1. 下标：字符串[string::size_type]的方法可以访问字符串的某一个值
      2. 迭代器：下标+迭代器的使用
         1. 部分的访问；有条件（更改循环条件即可）；随机访问

## 标准类型库vector

标准库vector表示对象的集合，是一个用于容纳其他类型的对象的“容器”。

vector是一个类模板——对于不同类型的对象需要使用不同“种类”的容器。

1. 定义和初始化对象`vector<T>`
   1. 普通方法
   2. 列表初始化vector对象
   3. 创建指定数量的元素
   4. 值初始化：
      1. `vector<T> v1(10,1),v2{10,1}`分别是指10个1；10和1两个元素
      2. 字符串的初始化只能够使用{}括号

2. 添加元素
   1. 类似于队列的添加方式，可以高效的在队列里增加元素
   2. `push_back()`
   3. 但是注意：for循环遍历的序列大小不能改变

3. 其他操作
   1. vector同样支持下标[]操作
   2. 下标元素不能够用来添加元素。空的vector不能够用下标访问。


## 迭代器

1. 迭代器可以用来访问容器类型中的对象。迭代器提供了对于对象的间接访问。
2. 使用迭代器：迭代器的本质上还是类似于指针的。
   1.  begin和end是两个指针，分别指向容器的开头和“尾后”。
   2.  迭代器运算符：基本和指针类似。*iter获取指向的值
   3.  将迭代器从一个元素移动到另外一个元素：直接增加就可以了，auto能够自动适应类型。
   4.  auto关键词是很好的，对于迭代器的实际类型应该是这种：`vector<int>::iterator`，auto能够自动对初始化的对象寻找合适类型，节省很多错误。它让C++看起来更像是动态语言。
   5.  cbegin和cend:指向常量的指针。
   6.  结合解引用和成员访问操作：所指向的对象有成员的时候可以使用解引用
       1. `iter->empty()`等价于`(*iter).empty()`
   7.  某些对vector对象的操作会让迭代器失效，比如改变容器的长度。
3. 迭代器运算：本质上还是类似于指针运算
   1. 算术运算：移动指针
   2. 使用迭代器运算：在计算例如二分搜索的时候很方便
      1. 注意的是，两个迭代器之间只有相减的运算而没有相加的运算。返回的是迭代器之间的“距离”——一个特殊的有符号的数据类型



## 数组

1. 数组是沿用自C语言的数据结构。数组大小不变，牺牲了一定的灵活性，但有时候性能更好。
2. 定义数组：
   1. `int *parr[size]`size必须是常量。数组的元素被默认初始化0。
   2. 数组也是对象的容器，不允许使用auto进行推断
   3. 显式初始化
   4. 字符的数组初始化允许直接使用一串字符串常量（自动添加结束空字符）
   5. 初始化不允许拷贝，用其他的数组给另一个赋值
   6. **重要区分**：数组的维度紧跟名字，（）相当于是把修饰符看作是名字的一部分，而不是数组类型了。
      1. `int *pr[10]`是指针的数组；`int (*pr)[10]`是指向int数组的指针。
      2. `int &pr[10]`是错误的，引用不是对象；`int (&pr)[10]`是int数组的引用
3. 访问数组元素
   1. 下标访问——本质上是对指针取值操作。
   2. 对指针解引可以获取值。
   3. 因此和对象索引的下标不同的是，数组的下标可以是负值——对应指针的前移。
4. 指针和数组：
   1. 使用数组的时候编译器一般会把它自动转化成指针。数组本身和C里面一样，大多数时候是指向数组首元素的指针。
   2. 因此数组的操作方法更多时候类似于指针。和迭代器操作也类似。
   3. 数组也有begin和end，不过由于数组不是对象，因此begin和end也是以函数的形式完成的。
      1. `begin(ia);end(ia)`返回值是指针，分别指向数组的开头和尾后。
      2. 这两个函数定义在标准库的iterator头文件中，使用时候需要引用。
5. 指针运算：和迭代器基本一样。意义也相同。
6. C风格字符串：尽量不要使用，是C语言标准库中提供的对C的字符串(`char str[]`这种)进行操作的一些方法。
   1. 用String类型就可以完成的操作和运算，在C语言中只能借助对应函数完成。
   2. 留下这个接口是用来给C语言提供一些衔接。通常可以用C字符串给C++赋值，但是反过来就不行。
      1. `char *str = s.c_str();`这个函数用来转换为C风格的字符串。
      2. `vector<int> ivec(begin(arr),end(arr))`可以把数组转化为vector。
   3. 不过还是建议尽量使用标准库类型而不要使用数组、

## 多维数组

1. 严格来说，C++没有多维数组，一般来说是C中数组的数组。

2. 初始化

3. 下标引用

   1. 使用for循环处理多维数组

4. 指针和多维数组

   1. 如何通过指针遍历数组？外层遍历内层数组的指针，外层指针取值获取内层数组的指针，再通过遍历内层指针访问指针指向的对象。
   2. 可以通过begin和end函数访问内层函数的开头和结尾。

5. 类型别名可以简化一些理解的工作。

   1. `using int_array = int[4];`

      `typedef int int_array[4];`二者等价，都是将int_array定义为4个整数的数组。



# Chapter 4-表达式

## 基础

1. 基本概念

   - 表达式，expression,由一个或者多个运算对象组成，对表达式求值将得到一个结果。
     - 字面值和变量本身就是最简单的表达式。
     - 用运算符连接多个运算对象组成复杂的表达式

   - 运算符：一元运算符、二元运算符（根据作用的对象），函数也是一种运算符
     - 组合运算符和运算对象：运算优先级
     - 不同的对象之间运算会自动进行一些简单的数据转换
     - 重载运算符：用户可以自行为一些内置的运算符赋予另外一层含义。

   - 左值和右值（lvalue & rvalue）：
     - 理论上感觉挺复杂的，在实践中自己判断就知道了。简单说就是一个对象在左右值时候是不一样的。左值在乎对象的地址，右值注重对象的值。
2. 优先级和结合律：

   1. 括号无视优先级和结合律。
   2. 为了确保程序正确性和可读性，多用点括号不会死。
3. 求值顺序

   1. 优先级规定了运算对象的组合方式，但是具体的求值顺序在大多数的情况下是没有指定的。

## 运算符

1. 算术运算符：加减乘除。
2. 逻辑关系运算符：比较和与或非关系
3. 赋值运算符：一定是一个可修改的左值。
   1. 对于类型来说，赋值运算的细节由类决定
   2. 赋值运算满足右结合，简单说就是从右向左。
   3. 赋值优先级较低。
   4. 复合赋值：赋值和运算结合，比如+=这种
4. 递增和递减运算符：
   1. 前置版本先加后返回，后置版本先返回后加。
   2. 非必要时候尽量使用前置。C语言其实也一样，不过C++再前置的时候不会像C语言一样对原来的值进行拷贝操作。
   3. 递增运算符号优先级高于指针解引。
      1. `*pbeg++`等价于`*(pbeg++)`。这样的写法非常常见，要能够一眼理解。
   4. 尽量不要再一个表达式中多次使用同一个会再表达式中变化的值。因为求值顺序的不确定。
5. 成员访问运算符：
   1. `(*p).size()`和`p->size()`等价。都是使用成员对象的size成员的方法。
6. 条件运算符：
   1. `cond1？expr1:expr2`语句，含义是判断真值，若为真则返回表达式1，否则返回表达式2。相当于是一个简化版的if-else语句。
   2. 嵌套条件运算符：上面那个语句可以嵌套使用。
   3. 输出表达式中可以使用条件运算符
7. 位运算符：
   1. `~ << >> & ^ |`分别是按位求反、左移、右移、位与、位异或、位或。
   2. 位移运算符会把移出边界的位舍弃
   3. 按位运算符号是单个，成双之后是逻辑运算符号。
   4. 位移运算符重载成为IO运算符，遵循向左结合律。
8. sizeof运算符
   1. `sizeof(type)`和`sizeof expr`,返回size_t类型，就是对于这个机器而言的字节数，例如char的size是1。
9. 逗号运算符
   1. 从左向右求值，连在一起作为一个表达式的时候返回右边的表达式结果。

## 类型转换

1. 表达式中存在一些类型不一致的运算，这时候会自动根据类型转换规则将对象进行“隐式转换”。
2. 算术转换：
   1. 整型提升：拓展长度来增大范围
   2. 无符号类型转化
   3. 很多时候是依赖机器的
3. 隐式类型转换：
   1. 数组转换为指针
   2. 指针转换
   3. 转为布尔类型
   4. 转换为常量
   5. 类类型定义的转换
4. 显式转换：`cast-name<type>(expression)`注意这种方法挺危险的。
   1. static_cast:任何具有明确定义的转换都可以
   2. `const_cast`:可以去除`const`性质
   3. `reinterptret_cast`:较低层次上的类型转化

## 运算符优先表

# Chapter 5 语句

## 简单语句

- 最简单的语句是空语句，使用时候注意注释来说明省略了什么。
- 语句使用；来分割
- {}分割复合语句（又称为“块”），是一块作用域
  - 复合语句的作用是将逻辑上的多条语句当作是语法上的一条语句使用
  - {}可以中间什么都不放，空块等价于空语句
- 作用域内定义的变量只在内部有效
  - while、switch、for、if的括号之内是一个语句作用域，因此括号内定义的变量会在离开它的作用域范围后自动销毁，第二次迭代调用语句时候都将初始化一次。
  - 要注意的是for的（）内语句作用域可以看作是一个“套在”循环块外层的作用域，因此在结束循环之前那个并不会被销毁。其它的如while、if、switch，它的括号内部作用域是单独的，因此其中定义的变量会在判断之后立刻销毁。

## 条件语句

1. if

   - 嵌套条件语句的else遵循的是就近选择。可以使用{}来指定控制路径。

2. switch

   - 括号内的表达式求值，然后转换成整数类型，再和case标签进行比较——匹配成功后执行语句直到遇到第一个break；

     - 有时候我们会有意省略一些break语句，让程序执行多条语句。

     - 有时候多种情况都是同一个执行的语句，也可以使用上面那个技巧：

       这种时候可以把多个标签写在一行语句之中，然后再写一句执行语句。

   - case必须是一个整常类型，不会自动转化，并且任意两个标签值不能相同

   - default是最后的匹配

   - 最后一点：switch内部的初始化（包括了隐式和显式初始化）是可能会被跨过的，但是其中的定义语句是不会跳过的（编译器决定，初始化和定义+赋值是完全不一样的）。可以在switch中定义和赋值，但是不能够再case中初始化。练习题5.13

## 迭代语句

1. while再不知道循环次数时候使用
2. for
   1. 传统格式
   2. 多重定义（多个对象，不过必须是同种类型）
   3. 省略头部分
   4. 范围for语句`for(declaration:expression)`
      1. 表达式必须是一个序列，作用是遍历其中的元素。
   5. do while语句

## 跳转语句

- break,continue,goto,return
  - 其中break只在迭代中和switch中使用，用于打断循环
  - continue只在循环内部使用，用于结束当前一次循环并开启下一次
  - 并且两者都作用于最近的循环。

## Try语句块和异常处理

- C++语言中的中断处理包括了throw表达式、try语句块、异常类。

- throw后面跟一个异常类，就可以做到直接抛出异常

- try语句块

  - 异常声明中是一个异常类

    ```c++
    try{
    	program-statements(程序)
    }catch(异常声明){
        handler-statements（处理异常语句块）
    }catch(){}...
    ```

- 标准异常：C++中定义的几种标准的异常类。



# Chapter5-函数

## 函数基础

和C语言基本一样的部分：

1. 编写函数
1. 函数声明：和其他的名字一样，一次定义可以被多次声明。一般来说会在头文件中进行函数的声明。
2. 调用函数
3. 形参和实参
   1. 实参是对形参的初始化的值，类型需要和形参匹配，能够被强制转化的值也是可以的
4. 形参列表
5. 返回类型

局部对象：

1. 在C++中，一个对象具有生命周期。
2. 函数体内的变量都是局部变量。同时也是一个“自动对象”，就是能够自动销毁自己的对象——函数的形参会在函数结束时候被自动销毁。
3. 局部静态对象：函数中static对象，能够在函数被调用结束之后不被销毁，直到程序的中止——因此当这个函数每次被调用的时候，对象都不会被初始化，会一直保持更新（顺带一提，这一点也能够证明在C中，对象的初始化和定义+赋值是不一样的）。

函数声明

​	所谓声明，是告诉编译器“名字”的过程——自我介绍？函数和变量只能够定义一次却能够被多次声明。

​	声明所需要的是“函数原型”。

​	我们常常将声明放在h文件里，而把定义放在源文件中。

分离式编译：如何把程序分开存储？

- 在编译的时候，需要告诉编译器所有的源文件，源文件之间的联系使用h文件。
- 修改了其中一个文件，只需要重新编译这个就行了。分离式编译时候会产生一个.obj或者.o文件，意思是包含对象代码（object code）。



## 参数传递

- 形参初始化机理和变量的初始化一样的机理。
- 如果形参是引用类型，将绑定到实参上（影响原来的变量）-引用传递，否则就只是将实参的值拷贝后赋值给形参-值传递。



1. 传值参数

   1. 指针形参：传递的指针同样也是一个拷贝值，但是这个值访问的数值将会是原本的值——因此利用指针形参也可以改变外面的值。

2. 传引用参数：

   1. 通过这种方式可以改变一个或者多个实参的值，它绑定了它初始化的对象。

   2. 另外，某些比较大的类对象（比如string之类的容器）拷贝起来很费力，或者有一些对象本身并不支持拷贝操作，无法使用值传递，想要在函数中引用时候这些一般都要使用引用传递，不过，为了防止原来的值被修改，最好将其声明为常量引用。如下所示：

      ```C
      bool isShorter(const string &s1 , const string &s2){};
      ```

3. const形参和实参

   1. 在形参列表中加入const意味着函数只能够读取变量但是不能够给它写值。形参中因为是值传递，因此并不能够继承实参的const性质。
   2. 形参的初始化方式和变量的初始化一样的，因此
      1. 复习：顶层const修饰的是指针，指针无法改变；底层const是指针指向了一个const的不能改变的对象。
   3. 应该尽量把不会改变的形参定义成常量引用，这样不容易产生误导，并且不会像非常量引用那样被限制实参类型——用了常量引用，是可以向这个参数里传递包括：const对象、字面值或者需要类型转换的对象。

4. 数组形参

   1. 数组的特殊性：无法被拷贝，被当作指针。因此以下3个函数声明等价：

      ```c
      void print(const int*);
      void print(const int[]);
      void print(const int[10]);
      ```

      它们三个传入的类型是一样的。形参中数组的大小只是期望，向其中传入的数组大小并不要求一定。

      但是因为长度不定，因此有时候需要一定的方法来指定数组长度。一般的方法有：

      - 使用标记指定
      - 标准库管理
      - 显式传递一个表示数组大小的形参

   2. 数组形参和const

   3. 数组引用形参

   4. 传递多维数组

5. main:处理命令行选项

   1. main的形参列表中传入两个可选的形参——

      `main(int argc,char **argv)`第一个参数对应字符串数量，而第二个则是一个C风格字符串的数组。第二个字符串中可以输入命令行命令字符串。

6. 含有可变形参的函数

   1. 当我们无法预知需要传递几个实参的时候可以使用`initializer_list`的标准库类型；或者可以编写一个可变参数模板。
   2. `initializer_list`是一个完全由同种类型的常量值组成的模板，将它座位形参就可以传入多个同类型的变量。

7. 省略符形参：在形参列表中加入`...`是为了便于访问某些特殊的代码而设置的

## 返回类型和return语句

1. 无返回值函数：void函数可以没有返回值，想要在这个函数中间提前退出写一句`return;`就可以了。

   1. void函数可以返回另一个void函数

2. 有返回值的函数：

   1. 返回一个值的方式和初始化一个变量和形参的方式完全一样：临时量的拷贝。

   2. 当然，可以返回引用或者指针——但是只能返回全局变量的。

      不要返回局部对象的引用或指针

   3. 返回类类型的函数和调用运算符
   4. 引用返回左值：函数调用放在赋值语句的左侧——返回值是引用，调用为左值是可以的。
   5. 列表初始化返回值：新标准中，函数可以返回花括号包围的值的列表。
   6. 主函数允许没有返回值。在在预处理的时候已经给了它返回值了。
   7. 递归：函数调用了它自身，就是递归

3. 返回数组指针

   1. 数组不能返回，但是数组指针可以。通常我们会定一个数组指针的类型别名。

   2. 区分`int *p1[10]和int (*p2)[10]=&arr`，前者是含有十个指针的数组，后者是指向10个整数数组的指针。

      1. 可以这样理解，第二种表达中p2本身是可以被解引用的，因此p2本身就是一个指针。

   3. 之所以要使用类型别名，大概是为了易于理解这样的函数声明——

      `int (*func(int i)[10])`可以逐层理解：func接受整数，func返回的是指针，并且指向大小为10的数组，数组内是整数。

4. 使用尾置返回类型

   `auto func(int i) -> int(*)[10]`：表明func返回一个指针，指针指向含有十个整数的数组

5. 使用decltype：知道返回哪一种对象的类型时候，可以这么搞——

   ```C
   int odd[]={1,2,3,4};
   decltype(odd) *func(){}
   //返回指向4个整数的C风格数组的指针。
   ```

   

## 函数重载

- 如果一个区域（namespace）内几个函数的名字相同但是形参列表不同，我们将其称为重载。编译器能够通过用户调用的时候传入的不同参数来判断使用的是哪一个函数。
- mian函数不能够重载

1. 定义重载函数
   1. 直接用同一个名字就行了。但是不能够接受参数相同但是返回类型不同，返回类型不同必须要形式参数也不同才能够成立重载。
   2. 形参的名字可以省略，一般只起到帮助理解和记忆的作用
   3. 由于顶层const（**顶层**表示指针本身是个常量，**底层**表示指针所指向的对象是个常量）不影响出啊内函数的对象，因此不会做出重载的区分。
   4. 一般来说，建议只给那些操作非常相似的函数进行重载。给函数起不同的名字能够便于理解。
   5. const_cast和重载：
   6. 调用重载的函数：
      1. 函数匹配（重载确定）：关联调用的和一组重载函数，一般来说编译器可能会：最佳匹配、无匹配、二义性调用。、
2. 重载与作用域：重载必须在同一个作用域之下，因为内外层之间的重载只会直接内层覆盖掉外层



## 特殊用途的语言特性

1. 默认实参

   1. C++允许函数自带参数的默认值，作为默认的实参。和Python的默认实参是一样的。传入参数按照从左到右的位置进行解析，不能够错位；
   2. 一旦函数被赋予默认实参，那么它的每个形参都需要被赋予默认实参。
   3. 声明：函数虽然可以被反复声明，但是声明过默认值的参数不能够再次被赋值。
   4. 表达式可以作为默认的实参，但是必须在函数的调用之前。

2. 内联参数和constexpr函数

   1. inline内联函数：内联函数的调用是一种“内联”地展开的。是需要在函数返回类型之前加上 inline就可以将它声明成为内联函数。

      对于一些比较简单短小、流程直接、频繁调用的函数，使用这种内联的做法可以节省内存开销。

   2. constexpr函数：能够用于常量表达式，它的返回值、以及所有的形参类型都是字面值类型，函数中必须有且仅有一条语句。

      1. 它的条件是函数中只包含常量表达式的相关运算。

   3. 把内联函数和constexpr函数放在头文件内（一般的函数只需要声明在头文件中，本身的逻辑包含在源文件里）。

3. 调试帮助

   1. assert是一种预处理宏。`assert(expr)`如果expr为真，那么assert将什么也不错，如果为假，assert将输出信息终止程序。

      它包含在头文件中，用来提前判断一些不希望发生的事情是否会发生。

   2. NDBUG预处理变量assert依赖于这个预处理变量，借用一些程序调用的名字和自带的预编译信息对于调试程序非常有用。

## 函数匹配（略）

重载中，几个形参的数量相等并且不同的类型之间存在相互转化关系的时候应该如何判断。

1. 确定候选函数和可行函数：能用的函数（基本符合，或者能够转换）；



## 函数指针

函数指针指向函数而不是对象。声明的方法简单说就是吧函数名字换成——`(*pointerName)`

此时我们可以把函数名字当成一个指针使用。指针名字当成这个函数使用。C语言中只能使用（*p）调用函数，但是C++中允许使用p直接代替函数名字调用。

1. 重载函数的指针：必须通过形参列表进行清晰界定，指针指向的到底是哪一个函数；

2. 函数指针形参：函数指针也可以被当作形参传入函数。

3. 返回值指向函数的指针：返回不了一个函数，但是能够返回一个函数的指针。返回类型携程一个指针函数即可。

   1. 一般来收使用类型别名简化。或者也可以使用置尾。

   2. ```c++
      auto f1(int)-> int (*)(int* , int );
      ```

4. 将auto和decltype用于函数指针类型：知道返回的是哪一个函数，就都能够用这种方法来确定类型。







# Chapter7-类

类的基本思想是数据抽象和封装——是一种利用接口（Interface）和实现（implement）的分离式变成艺术。

## 定义抽象数据类型

- 实战：设计一个Sales_item类。C语言中的做法一般是使用Struct来完成的。
- Step1——设计：从功能出发考虑一个类需要做到什么
  - 类的用户是程序员，一个优秀的类的设计者应该考虑编程者的需求去设计。
- Step2——定义：确定数据结构、接口、方法和成员
  - 引入概念：
    - this（成员函数内部，我们可以直接使用this调用对象的成员，this本质是一个常量指针，永远指向成员的地址，不能被改变） 
    - const 成员函数：常量成员函数，常量对象，常量对象的引用和指针都智能调用常量成员函数。this的类型是常量的，因此想要调用this也需要使用const成员函数。
  - 类作用域和成员函数：类本身就是一个作用域。
    - 在类的外部定义成员函数：可以，但是必须声明在内部，名字匹配并且包含所属的类名。



## 访问控制与封装

一般先考虑定义接口再制作封装，函数内有两个说明符：`public`和`private`决定了之后的成员是否能够被访问。

struct和class两个可以互换，唯一的不同在于使用前者































