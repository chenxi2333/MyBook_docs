

# 《C++求解工程问题》

这本书的目的在于巩固基础，通过解决实际问题，深入实际C++工程案例来快速熟悉C++基础。

同时，也需要通过这本书去学习工程问题求解的基本方法论。

# Chapter1 工程问题求解

## 计算机解决问题的历史

## 计算机系统

1. 硬件结构：冯诺依曼体系——储存、控制、IO、CPU
2. 软件结构：硬件——>操作系统——>应用
3. 计算机语言：C++是一门典型的编译语言。

## 数据表示与储存

- 二进制、计算机的地址位数、
  - 数制以及不同数制之间的转化
- 数据类型与储存——数据结构决定算法

## 解决工程问题的方法论

- 五个步骤：
  1. 清楚的描述问题
  2. 描述问题的输入和输出信息
  3. 使用一组简单的数据来解决问题
  4. 设计解决方案并计算机实现
  5. 使用大量数据测试解决方案。



# Chapter2 简单的C++程序

## 程序中一些解释

1. 操纵符：`iomainip`中的符号和变量，用来在流函数中操控流。
   1. fixed\setprecision：用来设置显示格式和有效数字
   2. setw：用来指定下一个发送到输出缓冲区的值的输出宽度
2. `std::endl`可以给标准输出结束之后换行并且立即刷新缓冲区。两个连写一般用来换行。
3. 基本的数学函数：与C中包含再`cmath.h`中的不同，C++风格中采用的是cmath库函数。包含了基本的运算、三角、双曲函数等。

## 小技巧

Alt+Shift可以多行选中。

案例介绍：涡轮的速度、加速度变换计算。

​	输入时间，输出对应的速度和加速度。



# Chapter3 控制结构：选择

## 一些技巧：为自定义的数据类型定义操作符

1. 一般成员的声明、类的声明和定义都放在头文件中，定义(类的实现)可以放在源文件中。

2. 重点在于类操作符的定义:有点类似于成员函数的定义方法，前面加了关键词operator，（const Point& rhs）这个是符号后的对象的调用，因为操作符不改变对象本身，因此使用了const。

   ```C++
   bool operator ==(const Point& rhs) const;//定义==号
   //表示返回为bool值， ==之前的是调用的对象，直接可以访问它的成员函数，==之后的对象是（）内的那个rhs。
   ```

   符号之前是调用这个函数的对象，符号之后是作用对象。

3. C++允许=赋值（或者说拷贝值）

   ```C++
   p1 = ORIGIN;//是可以直接赋值的
   ```

   

## 案例介绍：海水的冰点

1. 问题描述、输入和输出描述：本章将使用线性插值的算法来解决海水盐度的问题，给定海水的盐度确定新的冰点问题。

2. 确定数学模型，建立公式
   $$
   f(b)=f(a)+\frac{b-a}{c-a}(f(c)-f(a))
   $$

3. 算法设计：将问题分解为一组顺序执行的步骤。设计出流程图。

4. 编写程序

5. 测试



# Chapter4 控制结构：循环

## 案例介绍：气象气球

1. 问题描述：使用表示气球海拔高度和速率的多项式，打印出海拔高度和速率表，同时找出最大高度和对应的时刻。
   1. 输入起始时间、时间增加量、终止时间，输出海拔和速率值表、最大高度以及对应时间。
2. 数学建模：根据公式，建立对应的表。
3. 算法设计：分级提纲，提出步骤。设计算法
4. 实际解决问题
4. 测试数据



# Chapter5 使用数据文件

## 主要工具：流文件

1. 标准流对象cerr：它是一个非缓冲的流，输出到系统的标准错误输出设备。
   1. 所谓的缓冲流，是将数据存入一个缓冲区，缓冲区刷新时候数据才会被显示。
   2. iostream继承自istream和ostream。用于文件流的类ifstream以及ofstream分别继承自这两个类，这两个类包含在同一个头文件fstream中。
2. 在chapter5_1程序中初步练习了一下文件的简单操作
   1. 文件的打开与错误输出：注意需要C风格的字符串或者常量字符串才能当作文件名，string类只有被c_str转换之后才能够作为文件名。
   1. 文件的输出和输入流的控制和cin、cout基本一样（毕竟继承自同一个类）；
   1. 文件的关闭；
   1. 文件的结束符号使用eof可以检测。
3. 生成数据文件：基本思路差不多的
4. 错误检查：除了fail（）之外，有其他的方法可以测试输入流的状态
   1. 流的状态：`ios_base`通常被称作状态标志，是一组布尔变量。使用eof、fail、bad、good返回的正是相应的ios_base值。

5. 数值方法：回归





## 案例介绍

### 案例介绍1：数据过滤器——修改HTML文件

1. 问题描述：去除HTML文件中的所有标记，并将修改后的内容保存到一个新的文件夹中。
2. 建模：观察HTML文件
3. 算法设计：读取到<开始标记，直到读取到>结束。
4. 程序实现
5. 测试：
   1. 中文字符可以正常输入。
   2. 注意的是，''才能够和char类型匹配，使用""会发生错误。



### 案例介绍2：臭氧测量

1. 问题描述：输入数据文件，输出线性模型和高度范围
2. 建模：最小二乘法的线性回归
3. 算法设计
4. 程序实现
5. 测试：与书上的结果稍有不同，经过Matlab验证后计算得到我的程序有问题。后来发现eof检测文件结束，必须最后空出来一行或者输入一个空格字符，否则最后的一行数据会被忽略掉。



# Chapter6 函数模块化编程

1. 函数的声明又叫做原型。

2. 静态储存类static的值可以全局作用。它的存在不会随着函数退出而被销毁。

3. inline内联函数，小的函数可以在定义前使用inline关键词，作为内联函数（少一次声明）。

   > 留下一个疑问，C++中什么时候是必须使用指针形参而不能够使用引用形参的。

4. 随机数：包含在cstdlib中，可以用rand()生成一个0~RAND_MAX（0x7fff=32767），一般采用取模操作来限定范围。

   1. 经过实验可以得知：每次的随机函数调用都会生成一个新的随机数，但是每次程序生成的随机数并不会改变，即使重新编译也不行——伪随机数并且每次的种子并不会主动改变。
   2. 函数srand可以指定种子
   3. 想要定出浮点数的随机数，记得需要在除法过程中做一次强制的类型转换

5. 类中的方法封装

   1. 通过对私有成员建立一个方法用于访问。
   2. 私有的方法只有类本身的成员可以访问。


## 案例介绍

### 案例1：计算重心

1. 问题描述：输入成员的数量和货物的重量，输出总重量和重心。
1. 建模：一个简单的数学模型
1. 算法设计：这次需要采用分离式的设计，
1. 程序实现
1. 测试

### 案例2：仪器可靠性

1. 问题描述：针对与三个组件的配置方式，随机仿真解析可靠性和仿真可靠性。
2. 建模仿真
3. 算法设计：随机数实验
4. 程序实现：调用了之前写好的rand_float函数
5. 测试

### 案例3：复合材料的设计

1. 问题描述：输入关键半径，输出位于关键半径外的点的比例。、
2. 数学建模
3. 算法设计
4. 程序实现：这个程序中需要使用到联合编译的技巧——`g++ -o c6_4 .\chapter6_4.cpp .\Point.cpp`
5. 测试：同样记得要在最后留一个

### 案例4：系统稳定性

1. 问题描述：使用增量搜索的数值计算方法来确定一个多项式的副根。
2. 数学建模：主要是数值计算的方法，两端的点相乘若<0则能够知道点的位置。
   1. 另外一种方法使用的是牛顿-拉普森方法。
3. 算法设计：设定相差的最小阈值。
4. 程序设计
5. 测试

# Chapter7 一维数组

1. 函数参数：因为C语言风格的数组本质上是一个指针，因此应该使用数组+元素个数的方法去指定。
   1. 在C++中一般使用的是vector类。

2. 自定义头文件：将一些需要用到的头文件放到统一的文件下储存。

3. VScode中使用for的模板生成的可以使用Tab键快速修改内容。

4. getline(fin,crr,char)函数用来从流对象中获取一个函数，遇到停止，char默认情况下是'\n'符号。

5. 字符串：C语言的字符串和相关的处理函数、C++的字符串对象string类以及成员函数。

6. 类的初始化：构造函数不需要返回值。它是类的初始化的一部分。

7. 常量成员函数：函数之后加上const关键词。

   1. 首先需要明确，this是一个常量指针（本身指向不能够改变，但是指向的对象可以改变的底层指针）。

   2. 第二，C++的语言机制中常量指针是不能够去指向常量的。

   3. 因此，当this的对象是一个常量对象比如`const Chard X`这种，X是不能够调用this去指向X的成员函数的，因为this不是一个“指向常量的顶层指针”，不能够指向常量对象。具体的原理如下实验所示：

      1. ```c++
         const double pi=3.14;
         double* ptr1=&pi;//error1不合法，因为double的指针不能够指向const double 的地址
         double* const ptr2=&pi;//error2不合法，理由同上，虽然指针本身const但是不能改变指向的类型
         const double* ptr1=&pi;//ok1合法，指针的指向类型定义为了const
         const double* const ptr2=&pi;//ok2
         
         double pi = 3.14; 
         const double * ptr=&pi;//是合法的，因此const成员函数可以被非const的对象调用。
         ```

   4. 因此，给这个常量对象需要访问的函数增加const就可以正常访问了，同时这个函数非常量对象也能够正常访问。

      1. 这一个增加const的本质意义，就是为这个函数增加了一个隐藏的形参——`const Foo *this或者const Foo &this`（直接用这个参数代替const也可以，每次调用这个函数需要多调用一次this），由于多了这一层的定义，因此this指针能够正常指向const的对象，同时也由于指向const的指针能够正常去绑定普通的对象，因此普通的对象也能够调用这个成员函数。
      1. 常量成员函数函数的`a1.func1();//等价于a1.func1(&a1);//ok`


   5. 具体可以参考这个博客[ C++ const常量成员函数_NearXDU的博客-CSDN博客](https://blog.csdn.net/zhangxiao93/article/details/50599104)

## 案例介绍

### 案例：飓风等级

1. 问题描述：编写一个程序包含当前风暴信息的数据文件中读取数据，输出飓风标识号、飓风的峰值风速、飓风的等级
2. 数学建模
3. 算法设计：读取到的信息储存在数组中
4. 程序设计
5. 测试

### 案例2：语音信号分析

1. 问题描述：对于给定的连续数据，进行基本的数据处理。
2. 数学建模：统计学基础
3. 算法设计：无
4. 程序设计
5. 测试

### 案例3：海啸预警系统

1. 问题描述：输入采样得到的数据，分析后给出海啸波高数据。
2. 数学建模：无
3. 算法设计：提取最大的值、计算平均值等。

### 案例4：概率计算

1. 问题描述：独立同分布时间的概率计算
2. 数学建模：基本的伯努利试验的概率模型
3. 算法设计
4. 程序设计：设计并定义卡牌类。
   1. Card类两个属性：花色和点数
   2. 卡牌对象创建好之后不再改变，因此使用const类型
   3. CardDeck需要存储52张牌的vector，洗牌的过程使用了random_shuffle()完成。
   4. 书中展现了“类图”——用来表明类之间的关系。
5. 测试



# Chapter8 二维数组

1. 所谓二维数组，不过就是“数组的数组罢了”。不过二维数组的声明方法多种多样
2. 作为函数参数时候，直接传就行了——毕竟二维数组本质也是指针罢了。
3. 遍历二维数组先行还是先列本质上不会有什么不同，但是在一个程序中一定要统一。

## 案例介绍

### 案例1：地形导航

1. 问题描述：打印海拔数据，并输出峰顶位置
2. 数学建模
3. 算法设计：一个循环遍历
4. 程序设计：主要是熟悉一下二维数组的基本操作
5. 测试
