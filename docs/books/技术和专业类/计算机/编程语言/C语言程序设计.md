# Chapter 1 导言
- C语言无论大小如何，都是由函数和变量构成的，函数中包含了一部分的语句，来指定所需要执行的计算操作；变量则是用于储存计算过程中所使用的值。
> C语言的基本构成，从最开始就已经区分出了数据和控制。

- 数据类型的大小也取决于具体的机器。
- 尽管C编译器并不关心程序的外观样式，但是正确的缩进以及保留适当的空格的程序设计风格可以大大改善程序的易读性。
- 整数的算术计算的表达式中，一般把乘法提到最前，除法移动到最后。因为C语言中整数除法操作将进行舍位。
- printf函数不是C语言的一部分，而是标准库函数中一个有用的函数。ANSI标准定义了printf的行为。
- EOF是定义在头文件stdio中的结束符号，是一个整数型，这个符号与任何一个char都不相同。EOF整数值中是-1；
   - 这个程序弄懂就要明白每次输入的时候只有回车之后才能算作真正的“输入”。所以其实虽然看上去是字符串的输入其实程序接收到的还是单个字符，然后处理的。
- 数组的初始化非常重要，不然里面的内容全是乱的。
- C语言的函数传递的是值传递，在函数中使用的是实际值的副本。这一点与之前的语言如Pascal是不同的。
- 字符数组，又称为字符串，是C语言中最为常用的一种数组类型。
   - 字符串默认以'\0'结尾，自己创建的时候需要记得加上去。这是C语言的规定，即字符串一定要以空字符\0结束。
- 外部函数定义在**所有**函数之外，包括main函数，内部调用这些变量需要使用extern，一般可以隐藏。当外部变量出现在函数之前，函数中就可以隐藏。
   - 外部文件的变量引用需要extern声明建立联系，通常这些都包含在头文件中。
   - 外部变量好处在于简化而缺点在于数据安全性无法得到保证。并且会大幅增加程序的耦合程度。
- 定义define用于创建变量或分配储存单元；而声明declearation则是说明一个变量的性质，并不实际分配储存单元。

# Chapter 2 类型、运算符与表达式

- 变量名：_被看作是一个字母，通常可以用于长变量名，但是一般不用在开头，因为库例程的名字通常以下划线开头。
   - 一般来说变量名的选择要体现表达变量的用途，局部变量一般较短而外部变量一般会比较长。
- 数据类型以及长度：
   - C语言只提供了四种基本的数据类型，char（1） int（4） double（8） float（4） ;
   - short long是可以加上的限定字符，short（2）或者long（4、8） 后int可以省略。long 的实际长度会根据具体的机器字长改变。
   - unsigned和signed表明了字符的编码方式，后者可以表示负数。
   - 具体的范围可以在limits头文件的定义中找到。
   - 要注意的是printf中的%表示了以何种形式输出什么样的数据类型。
- 常量：
   - 常量加上后缀可以表示特定的数字类型。u是unsigned，l是long。转义字符整体算作一个字符。
   - 字符串常量也叫字符串字面值。技术上讲是字符数组，以\0结尾。
   - 枚举常量，如enum boolean{ NO , YES}这样。其中包含的都是常量类型，默认第一个是0，后面默认递增，也可以直接指定一些常量值。同一个枚举之中不同名字可以有相同的值，但是所有的枚举中名字都必须不同。
   - 枚举好处是直接自动生成一系列的常量，让程序显得美观。想要遍历一个枚举需要使用这个枚举的枚举变量，同时要求枚举中的值必须要是连续的。此外相比#define，枚举类型更好的一点在于枚举变量可以被检查，保证变量是枚举类型中的值。
- 声明：所有的变量必须先声明后使用，只不过有时候可以隐式声明。
   - 声明=数据类型+变量名
   - 声明的同时可以初始化变量，初始化对于非自动变量而言智能进行一次且必须是常量表达式。

# Chapter 3 控制流

- if-else 语句
- else if语句
   - C语言中一般可以使用time标准库中的一些函数来测试运行时间。时间间隔如果太小可以使用大量次数迭代的方法来延长。
- switch语句
   -  case后面跟的是常量表达式。
   - break不添加会直接执行下一个分支的执行语句。
- while和for循环
- do-while
   - 与之前的最大不同在于，循环体至少执行一遍。
- break-continue语句
   - 作用是不通过循环头部或者尾部的条件测试跳出循环。break直接跳出循环，而continue则是会直接开始下一次的循环部分。
- goto语句
#  Chapter 4 函数与程序结构

- 函数的意义是封装具体的细节，使得整个程序的结构更加清晰，降低修改程序的难度。
- 最简单的函数 dummy(){}可以既不包含返回值也没有任何操作，经常被用来在开发时保留位置。省略返回值类型默认为int，没有返回值默认返回0。
- 非整数返回值的函数需要声明，声明和定义需要类型一致，如果定义的文件和声明的位置不在同一个文件，这种错误类型是无法被检测出来的。
- 隐式声明：如果一个函数没有声明就直接使用，编译器会认为默认返回为int，对于参数没有任何限制假设。
- 外部变量：
   - C语言本身不允许在函数中定义函数，因此，函数一定是外部的。外部变量可以任意访问，但是如果太多则需要一个参数表来整理规划，这样程序很容易出错。
   - 区分外部变量的定义与声明
      - 定义只需要并且只能一次，没有extern。定义时候为变量分配了内存空间。
      - extern使用在声明中，表明使用外部的变量，并不会为这个变量分配内存空间。
- 头文件：
   - 对于一个中等规模的程序，最好只用一个头文件存放程序中共享的部分。 
- 静态变量：
   - 以static开头的变量，作用域限定为被编译源文件剩余部分——这个变量或者函数仅仅在这个文件中可以被调用，可以用这个关键隐藏外部对象。
   - 只会初始化一次。（自动变量会在每次进入程序或者函数的时候都会初始化一次）
- 寄存器变量：register声明，可以让一些使用频率较高的变量直接存放在机器的寄存器里，以加快程序的执行速度。
- 初始化：
   - 外部变量：只能常量表达式来初始化；
   - 静态变量：只能常量表达式来初始化，并且只能初始化一次。
   - 自动变量的初始化等效于简写的赋值语句。
   - 数组的初始化：{元素}，没有初始化的元素将被初始化为0，省略长度会自动把初始化长度作为数组长度。
      - 字符数组的初始化可以直接使用字符串常量去初始化。
- 递归：调用自身的函数。
- C预处理器：
   - 最常用的是文件包含include和define
   - <>一般从环境中查找文件，“”会从自身位置查找文件。
   - define宏替换：替换简单粗暴，并且几乎没有限制。
      - 并且宏定义可以带参数，但是如果出现自增运算符或者输入、输出的情况，它会对两个参数各执行多次的自增操作——原理也很简单，其实就是因为宏函数里出现了两次A，因此被替换成了两个++x，因此自增被执行了两次。
      - #undef 可以取消名字的宏定义。
      - #开头的宏函数参数会以字符串的形式被直接替换。
      - ##可以连接参数。
   - 条件包含#if #elif #endif：
      - 表示如果成立则继续编译，否则跳到endif
      - 一般用法是紧跟一个#define FLAG 给文件做一次标识，防止重复编译。、
      - 另外一种用法是测试系统变量。
      - #ifdef 和 #ifndef 等效于 #if defined() 和 #if |defined()。
# Chapter 5 指针与数组

- 指针是一种保存变量地址的变量。
- 指针长度是2或者4个字节。
   - &是取址运算的符号。可以获取变量的地址。
   - *是寻址（引用）运算符，可以访问指针指向的对象。
   - int *ip 这种定义方式可以这样理解：*ip这个变量的类型是int，ip则是指向int类型的指针。
2. 指针与函数参数：
   - C语言的函数用的是传递值的方法调用函数，在函数中传递地址的形参就可以对值进行操作。
3. 指针与数组：
   - 数组本质上就是一个“固定位置”的指针。指针可以变化位置，但是数组始终指向同一个储存位置。
   - 数组的本质就是连续的指针，因此数组的操作可以被指针操作同等的进行替代。
   - 数组名和指针命区别在于指针是变量而数组不是，因此指针可以合法赋值或者运算而数组名则不能够。
   - 通常为了便于理解，我们通常习惯于定义 char *s;这样可以直接传入function(char *s)中，更加直观。
      - 对于函数来说，并不在意引用的对象是不是数组的开头，函数引用的本质上都是指针。
4. 地址算术运算：
   1. 将数组、指针和地址的算术运算集成在一起是C语言的一大优点。
   2. 书中通过指针的算数运算实现了一个不太完善的空间分配。
   3. 指针函数：返回指针类型的函数。
   4. 指针可以赋值常量0，等同于NULL。
   5. 指针的算术运算通常是在一段连续的地址空间中才有效果。
      - 比较大小即为前后关系，
      - p+n即为在p指向的对象之后第n个对象的地址。
      - p-s是两个指针之间的元素个数，这一点可以用来计算数组长度。
   6. 指针的算术运算一致性：是指指针的算术运算实际加或者减去的是与指针类型一致的。
5. 字符指针与函数
   1. 字符串常量是一个字符数组指针。以 \0结尾。
   2. 字符串常量可以被赋值给 ： char * 的指针，可以改变位置来访问字符串的每一个字符，但是无法通过这个指针来改变字符串常量的值；char XX[]，始终指向同一个位置，但是可以改变字符串内的值。
      - 之所以如此，是因为前者的初始化相当于把字符串定义为了一个整体的常量。而后者是看作一个变量的数组来初始化的。
      - 设计的实验结果证明确实如此。指针初始化的时候赋值的字符串无论用数组方法还是指针方法都只能读取无法改写，后者可以用指针和数组方法读写；指针指向了一个用数组方法初始化的字符串则可以进行改写。能否改写关键在于字符串本身为常量还是变量数组。
   - 指针本身就能作为一个字符串名字使用。 
6. 指针数组以及指向指针的指针：
   - 与高维数组相比，定义指针数组的好处在于每一个元素可以自由的定义长度。更加自由。
   - 另外一点就是移动指针要比直接移动内容要方便多了。
   - 对于指针数组 char *lineptr[]来说，linpter[i]是数组的第i个，*linpter[i]是第i个数组的第1个元素。
   - 指针数组最常用的方法还是存放长短不一样的字符串。char *argv[]。
7. 多维数组：并不能够像指针数组使用那样广泛。
   1. 数组的本质都是指针。数组的名字一般都能够和指针等价，也能够给同类型的指针赋值。同样，数组的[i]引用方式对于指针来说同样是合法的。
8. 命令行参数main(argc,argv)
   1. 前者用于参数计数，至少为1；后者是参数向量。程序echo可以清晰的表示这种参数列表。
   2. 后者的类型就是一个指针数组。
9. 指向函数的指针
   1. 定义指向函数的指针，可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等。
   2. 在例子中，我们看到qsort中用一个int (*comp)(void *, void*)代替了strcmp，这样我们可以通过传入不同地参数来进行各种类型地排序。
   3.  int (*comp)(void *, void *) 是指针函数的声明方式； 
   4. int *comp(void *, void *)  是返回int指针的函数。
10. 复杂声明：
   1.  尽管实际中很少用到过于复杂的声明，但是，懂得如何理解甚至如何使用这些复杂的声明是很重要的。 
   2.  比较复杂的类型声明，可以通过typedef 通过简单的步骤合成。
   3. 另外一种方法是将正确的C语言转换为文字描述，另一个程序完成相反的转换。dcl程序。

# Chapter 6 结构

- 结构是一个或者多个变量的集合，这些变量可以为不同的类型。
   - 结构可以拷贝、赋值、传递给函数，或者作为返回值。
## 基本知识

1. 结构名字称为结构标记（struct），结构中定义的变量称为成员（member），struct声明定义了一种数据类型，在struct后可以定义变量表。
   - 结构变量在初始化的时候分配了存储空间，如果没有变量表就不需要分配储存空间
   - struct Name variables = ；这样的语句可以定义一个结构变量。
   - 结构变量可以看作是一个自己定义的数据类型，C语言中的“类”与对象的概念。想要使用这个类，需要的就是struct NAME这样的一个说明。
   - struct的声明中确定了这个数据类型所需要的空间，本质上就是在内存上“规定”了一块确定大小的空间。sizeof(类型名) 和 sizeof 对象 可以返回占用的储存空间字节数。
2. 结构的合法操作：整体的赋值和复制、&取址操作、访问成员——基本等同于一个新的数据类型。
   - 初始化：常量结构列表。
   - 函数中：可以作为返回变量和传入参数。
3. 但如果一个结构本身很大，想要作为参数传入就需要复制很大的空间，相比之下传入指向结构的指针更加高效。
   1. struct point *(pp); 是定义结构指针
   2. (*pp).XX则是引用结构成员等价于另一种写法——pp->结构成员。
   3. 结构引用符号->和.的优先级高于其它的各种（如++和*）符号，优先计算的是结构运算符。
4. 结构数组与指向结构的指针
   1. tip: mid = (low+high)/2作为指针运算的话是非法的，但是mid = low + (high-low)/2则是合法的指针运算。
   2. 对齐：结构中会因为对其出现空穴——比如一个结构大小如果是5字节，系统会自动对齐给它8个字节的储存空间，sizeof也会返回8字节。
      1. 很好理解——旅馆分配房间，一个64位系统每间房能够住8个char或者2个int。原来都没有问题，现在游客组团而来（struct），那么为了不让不同团的旅客“混在一起”，系统会给1个char1个int的团一个完整的房间，虽然没有住满但是能够保证安全。
5. 自引用结构：
   1. 结构声明内不能包含自己结构的递归声明，但是可以包含指向自己结构的指针。
   2. 结构内包含自己或者另外一个结构的指针，让指针之间互相引用，就是自引用结构。
   3. 这种自引用结构在二叉树结构中经常运用。
6. 表查找
7. 联合：union
   1. 声明和访问成员的方法都和结构相同，但是作用上大相径庭——联合的长度取决于最长成员的长度，它能够保存成员中的任何一种。
   2. 本质上是一个全部成员基地址的偏移量都是0的“结构”。
8. 位字段：
   1. 想要压缩空间让空间不再空闲的方法，一种是通过屏蔽字段来“切割”变量。另外一种方法就是用位字段。
   2. struct{ type [name]:width;}variables可以规定成员的位数（bits）。
   3. 注意，位字段的存储取决于机器因而不可移植——并且没有地址，无法取址运算。

# Chapter 7 Input  and Output

- 标准输出和输入：
   - getchar & putchar
- 格式化输出printf：
   - 用format进行控制。是一个输入被称为format的函数。printf(char * , ...)
   - printf使用了变长参数表，可以输入任意长度的参量。
   - 变长参数表通过一个定义在stdarg中的参数指针去处理。
   - va_arg会只想第一个“无名参数”，然后每次读取指定长度的数据。
- 格式化输入scanf：
   - scanf的全部作用其实是按照format中的格式进行解释,并且保存到后面的地址中
   - 比如scanf("%d %s %d",&day , monthname , &year);后面的参量必须是指针。
   - sscanf用于整理字符串格式。sscanf(char *, format, ...)
- 文件访问：
   - fopen函数返回一个文件指针FILE *。文件指针指向一个文件信息。
   - FILE是用typedef定义的一种“类型名”。
   - fopen(name,mode);
   - mode包括"r""w""a"，读写追加。
   - 文件的读写有两个宏getc(FILE *fp) putc(FILE *fp);
   - 也同样有两个函数fscanf和fprint，第一个参数都是文件指针。后面的使用和printf 和scanf一样。
- 错误处理：
   - stderr:标准异常流。
   - exit:终止进程。
- 行输入和行输出：fgets和fputs
- 其他标准库函数：详见附录B
   - 字符串处理
   - 字符类型测试和转换
   - ungetc
   - 命令执行函数
   - 存储管理函数 malloc calloc free
   - 数学函数
   - 随机数发生函数
# Chapter 8 UNIX系统接口

- UNIX系统内有一些函数能够被直接调用。
- 文件描述符：
   - UNIX中一切皆文件的思想，让程序能够只需要通过访问文件的方式，就可以处理外围设备和程序之间的所有通信。
- 低级IO
   - read/write
- open\creat\close\unlink
- 随机访问lseek
- 实例——fopen/fgetc函数的实现
- 实例——目录列表
- 实例——存储分配程序


